<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Defora Web</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/vue@3.4.27/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --bg: #06080f;
      --panel: #0f1422;
      --panel-2: #11182d;
      --border: #1f2a44;
      --glow1: #ff53d9;
      --glow2: #2de2ff;
      --text: #e8edf7;
      --muted: #9bb1d0;
      --success: #5af2a9;
      --danger: #ff4d6d;
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", Arial, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(255, 83, 217, 0.12), transparent 25%),
                  radial-gradient(circle at 80% 0%, rgba(45, 226, 255, 0.12), transparent 25%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 12px 16px;
      background: rgba(13, 18, 34, 0.8);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(6px);
      display: grid;
      grid-template-columns: 1.4fr 1fr 1fr;
      gap: 10px;
      align-items: center;
    }
    .brand { font-weight: 700; letter-spacing: 0.5px; font-size: 18px; }
    .tabs { display: flex; gap: 6px; flex-wrap: wrap; }
    .tab { padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border); background: #0f172a; color: var(--muted); cursor: pointer; }
    .tab.active { border-color: var(--glow2); color: var(--text); box-shadow: 0 6px 20px rgba(45,226,255,0.12); }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 999px; border: 1px solid var(--border); background: #11182d; color: var(--muted); font-size: 12px; }
    .pill .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); box-shadow: 0 0 8px var(--success); }
    .pill.danger .dot { background: var(--danger); box-shadow: 0 0 8px var(--danger); }
    .btn { background: linear-gradient(90deg, var(--glow1), var(--glow2)); color: #0a0c12; border: none; border-radius: 999px; padding: 8px 12px; font-weight: 700; cursor: pointer; }
    .btn.ghost { background: #0f172a; color: var(--text); border: 1px solid var(--border); }
    .layout { flex: 1; display: grid; grid-template-columns: 1.8fr 1fr; gap: 10px; padding: 10px; }
    .preview { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); padding: 10px; display: grid; gap: 10px; }
    .video-wrap { position: relative; border-radius: var(--radius); overflow: hidden; border: 1px solid var(--border); background: #000; }
    video { width: 100%; display: block; background: #000; }
    .overlay { position: absolute; left: 0; right: 0; bottom: 0; display: flex; justify-content: space-between; padding: 8px 10px; background: linear-gradient(180deg, transparent, rgba(0,0,0,0.7)); font-size: 12px; }
    .timeline { background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 8px; }
    .thumbs { display: flex; gap: 8px; overflow-x: auto; margin-bottom: 6px; padding-bottom: 4px; }
    .thumb-card { position: relative; border-radius: 10px; overflow: hidden; border: 1px solid var(--border); background: #0b0f1c; box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
    .thumb { width: 92px; height: 54px; display: block; background: #11182a; object-fit: cover; }
    .thumb-label { position: absolute; left: 0; right: 0; bottom: 0; padding: 3px 6px; font-size: 11px; color: var(--text); background: linear-gradient(180deg, transparent, rgba(0,0,0,0.7)); }
    .wave { height: 40px; border-radius: 8px; background: linear-gradient(90deg, rgba(255,83,217,0.2), rgba(45,226,255,0.2)); border: 1px solid var(--border); }
    .rack { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .rack h3 { margin: 0 0 8px 0; }
    .slider-row { display: grid; grid-template-columns: 1.1fr 1fr; gap: 8px; align-items: center; margin: 8px 0; font-size: 13px; color: var(--muted); }
    .slider-row input[type=range] { width: 100%; accent-color: var(--glow2); }
    .source { display: inline-flex; gap: 6px; font-size: 12px; color: var(--muted); align-items: center; }
    .chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { padding: 8px 12px; border-radius: 999px; border: 1px solid var(--border); background: #11182a; color: var(--text); cursor: pointer; }
    .chip.active { border-color: var(--glow2); color: var(--glow2); }
    .context { grid-column: 1 / span 2; background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; }
    .context h4 { margin: 0 0 6px 0; }
    .table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text); }
    .table th, .table td { padding: 6px 8px; border-bottom: 1px solid var(--border); text-align: left; }
    .xy-pad { width: 140px; height: 140px; border-radius: 12px; border: 1px solid var(--border); background: #0f172a; position: relative; cursor: crosshair; user-select: none; }
    .xy-dot { position: absolute; width: 12px; height: 12px; border-radius: 50%; background: var(--glow2); box-shadow: 0 0 10px var(--glow2); }
    .lfo-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; }
    .lfo-card { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: #0e1322; box-shadow: 0 8px 18px rgba(0,0,0,0.28); }
    .lfo-card h4 { margin: 0 0 6px 0; display: flex; align-items: center; justify-content: space-between; font-size: 14px; }
    .lfo-card .meta { font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    .lfo-card select, .lfo-card input[type=number] { width: 100%; padding: 6px; border-radius: 8px; border: 1px solid var(--border); background: #0f172a; color: var(--text); }
    .lfo-card .switch { display: inline-flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px; color: var(--muted); }
    .audio-map-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: 10px; }
    .audio-map-card { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #0f172a; }
    .framesync-panel { background: #061726; border: 1px solid #0c2c3f; border-radius: 10px; padding: 10px; box-shadow: inset 0 0 0 1px rgba(11, 72, 104, 0.35); }
    .framesync-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; color: #cde5f7; font-weight: 600; letter-spacing: 0.6px; }
    .framesync-title { font-size: 18px; }
    .framesync-accent { color: #ff8a1a; }
    .framesync-graph { margin-top: 10px; background: #031b2d; border: 1px solid #0c3048; border-radius: 8px; padding: 6px 10px; }
    .framesync-axis { display: grid; grid-template-columns: repeat(12, 1fr); gap: 0; margin-top: 6px; font-size: 10px; color: #7fb3d6; }
    .framesync-axis span { text-align: center; }
    .framesync-row { display: grid; grid-template-columns: 1.1fr 2fr 1.2fr 1.2fr; gap: 12px; margin-top: 12px; }
    .framesync-stack { display: grid; gap: 10px; }
    .framesync-subtitle { font-size: 12px; color: #9bc4e2; margin-bottom: 6px; letter-spacing: 0.3px; }
    .framesync-list { font-size: 12px; color: #cfe5f5; }
    .framesync-list .item { padding: 4px 0; border-bottom: 1px solid rgba(12, 48, 72, 0.6); }
    .framesync-list .item:last-child { border-bottom: none; }
    .framesync-select, .framesync-input { width: 100%; padding: 6px; background: #03192a; border: 1px solid #0c3048; border-radius: 4px; color: #cfe5f5; font-size: 12px; }
    .framesync-buttons { display: grid; grid-template-columns: repeat(auto-fit, minmax(64px, 1fr)); gap: 6px; }
    .framesync-button { background: #061b2d; border: 1px solid #0f3c5c; color: #cfe5f5; font-size: 11px; padding: 6px 4px; text-align: center; border-radius: 4px; cursor: pointer; }
    .framesync-button.active { border-color: #ff8a1a; color: #ffbf80; }
    .framesync-metric { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 12px; color: #cfe5f5; }
    .framesync-metric span { display: block; color: #7fb3d6; font-size: 10px; }
    .framesync-wave-shapes { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; margin-top: 6px; }
    .framesync-wave { background: #031b2d; border: 1px solid #0c3048; border-radius: 6px; padding: 6px; text-align: center; font-size: 10px; color: #cfe5f5; }
    .framesync-wave svg { width: 100%; height: 40px; display: block; margin-bottom: 4px; }
    .framesync-footer { margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; }
    .framesync-toggle { display: flex; align-items: center; gap: 6px; font-size: 11px; color: #cfe5f5; }
    .framesync-dot { width: 10px; height: 10px; border-radius: 50%; background: #ff8a1a; box-shadow: 0 0 8px rgba(255, 138, 26, 0.6); }
    .compact-panel { background: #0f1422; border: 1px solid var(--border); border-radius: 12px; padding: 10px; display: grid; gap: 8px; }
    .compact-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 8px; }
    .mod-row { display: grid; grid-template-columns: 24px 1.2fr 1fr 70px 70px 1fr 36px; gap: 6px; align-items: center; font-size: 12px; }
    .mod-row .select, .mod-row input { width: 100%; }
    .mod-row .chip { padding: 6px 8px; font-size: 11px; }
    .mod-row button { background: #0f172a; border: 1px solid var(--border); color: var(--text); border-radius: 8px; padding: 4px 6px; cursor: pointer; }
    .mod-header { display: flex; align-items: center; justify-content: space-between; font-size: 12px; color: var(--muted); }
    .mod-preview { grid-column: 2 / span 5; background: #0c1324; border: 1px solid var(--border); border-radius: 8px; padding: 6px; }
    .mod-preview svg { width: 100%; height: 36px; display: block; }
    .mod-subheader { font-size: 12px; color: var(--muted); margin-top: 6px; }
    @media (max-width: 1100px) {
      .layout { grid-template-columns: 1fr; }
      .context { grid-column: 1; }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="brand">Defora ¬∑ Session: {{ session }}</div>
      <div class="tabs">
        <button class="tab" v-for="tab in tabs" :key="tab.id" :class="{active: currentTab===tab.id}" @click="switchTab(tab.id)">
          {{ tab.label }}
        </button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
        <button class="btn" @click="sendControl('transport',{action:'toggle'})">‚èØ</button>
        <button class="btn ghost" @click="sendControl('transport',{action:'stop'})">‚èπ</button>
        <button class="btn ghost" @click="sendControl('transport',{action:'record'})">‚óè Rec</button>
        <div class="pill"><span>FPS</span><strong>{{ stats.fps }}</strong></div>
        <div class="pill"><span>Lat</span><strong>{{ stats.lat }}ms</strong></div>
      </div>
    </header>

    <div class="layout">
      <!-- Left: video + mini timeline -->
      <div class="preview">
        <div class="video-wrap">
          <video id="player" controls autoplay muted playsinline></video>
          <div class="overlay">
            <div>Time {{ timecode }}</div>
            <div>Seed {{ hud.seed }}</div>
          </div>
        </div>
        <div class="timeline">
          <div class="thumbs">
            <template v-if="thumbs.length">
              <div class="thumb-card" v-for="t in thumbs" :key="t.src">
                <img class="thumb" :src="t.src" loading="lazy" :alt="'frame '+frameLabel(t)" />
                <div class="thumb-label">#{{ frameLabel(t) }}</div>
              </div>
            </template>
            <template v-else>
              <div class="thumb-card" v-for="n in 6" :key="'ph'+n">
                <div class="thumb"></div>
                <div class="thumb-label">waiting‚Ä¶</div>
              </div>
            </template>
          </div>
          <div class="wave"></div>
        </div>
      </div>

      <!-- Right: control rack per tab -->
      <div>
        <div v-if="currentTab==='LIVE'">
          <div class="rack">
            <h3>Vibe & Style</h3>
            <div class="slider-row" v-for="p in liveVibe" :key="p.key">
              <div>{{ p.label }}</div>
              <div>
                <input type="range" :min="p.min" :max="p.max" :step="p.step" :value="p.val" @input="updateParam(p,$event)">
                <div class="source">
                  <span :title="sourceTip(p)">Source: </span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Manual'}" @click="setSource(p.key,'Manual')">Manual</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Beat'}" @click="setSource(p.key,'Beat')">üåä Beat</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='MIDI'}" @click="setSource(p.key,'MIDI')">üéõ MIDI</span>
                </div>
              </div>
            </div>
          </div>
          <div class="rack">
            <h3>Camera</h3>
            <div class="slider-row" v-for="p in liveCam" :key="p.key">
              <div>{{ p.label }}</div>
              <div>
                <input type="range" :min="p.min" :max="p.max" :step="p.step" :value="p.val" @input="updateParam(p,$event)">
                <div class="source" v-if="p.sourceable">
                  <span class="chip" :class="{active: paramSources[p.key]==='Manual'}" @click="setSource(p.key,'Manual')">Manual</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Beat'}" @click="setSource(p.key,'Beat')">üåä Beat</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='MIDI'}" @click="setSource(p.key,'MIDI')">üéõ MIDI</span>
                </div>
              </div>
            </div>
            <div class="chips">
              <span class="chip" v-for="p in Object.keys(motionPresets)" :key="p" @click="sendPreset(p)">{{ p }}</span>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='PROMPTS'">
          <div class="rack">
            <h3>Positive prompt</h3>
            <input class="select" v-model="prompts.pos" @change="sendPrompts" placeholder="positive prompt" />
            <button class="btn ghost" style="margin-top:6px;" @click="sendPrompts">Apply prompt</button>
          </div>
          <div class="rack">
            <h3>Negative prompt</h3>
            <input class="select" v-model="prompts.neg" @change="sendPrompts" placeholder="negative prompt" />
            <button class="btn ghost" style="margin-top:6px;" @click="sendPrompts">Apply negative</button>
          </div>
          <div class="rack">
            <h3>Prompt morphing</h3>
            <div class="chips">
              <span class="chip" :class="{active: prompts.morphOn}" @click="setMorph(true)">‚òë Enable</span>
              <span class="chip" :class="{active: !prompts.morphOn}" @click="setMorph(false)">‚òê Disable</span>
            </div>
            <div class="wave" style="margin-top:6px; height:24px; background: linear-gradient(90deg, var(--glow1), var(--glow2));"></div>
          </div>
        </div>

        <div v-else-if="currentTab==='MOTION'">
          <div class="rack">
            <h3>Camera pad</h3>
            <div class="xy-pad" 
              @mousedown="xyPadMouseDown" 
              @mousemove="xyPadMouseMove" 
              @mouseup="xyPadMouseUp" 
              @mouseleave="xyPadMouseUp"
              @touchstart="xyPadMouseDown"
              @touchmove="xyPadMouseMove"
              @touchend="xyPadMouseUp">
              <div class="xy-dot" :style="{left: xyPad.x + 'px', top: xyPad.y + 'px', transform: 'translate(-6px, -6px)'}"></div>
            </div>
            <div style="font-size: 11px; color: var(--muted); margin-top: 6px;">
              Click/drag to control camera pan (X/Y translation)
            </div>
          </div>
          <div class="rack">
            <h3>Zoom & Tilt</h3>
            <div class="slider-row">
              <div>Zoom</div>
              <input type="range" min="-5" max="5" step="0.05" value="0.8" @input="sendControl('liveParam',{translation_z: parseFloat($event.target.value)})">
            </div>
            <div class="slider-row">
              <div>Tilt</div>
              <input type="range" min="-180" max="180" step="0.5" value="0" @input="sendControl('liveParam',{rotation_z: parseFloat($event.target.value)})">
            </div>
          </div>
          <div class="rack">
            <h3>Motion style</h3>
            <div class="chips">
              <span class="chip" v-for="m in motionStyles" :key="m" @click="sendControl('motionStyle',{style:m})">{{ m }}</span>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='AUDIO'">
          <div class="rack">
            <h3>Track & tempo</h3>
            <div class="slider-row" v-if="audio.uploadedFile">
              <div>Track</div>
              <input class="select" v-model="audio.track" readonly>
            </div>
            <div class="slider-row">
              <div>Audio file</div>
              <input type="file" accept="audio/*" @change="handleAudioUpload" style="font-size:12px;" ref="audioFileInput">
            </div>
            <div v-if="audio.uploadedFile" class="chips" style="margin-top:4px;">
              <span class="chip">üìÅ {{ audio.uploadedFile }}</span>
              <span class="chip" @click="clearAudioFile" style="cursor:pointer;">‚úï Clear</span>
            </div>
            <div class="slider-row">
              <div>BPM</div>
              <input class="select" type="number" v-model.number="audio.bpm">
              <span class="pill" :class="{'danger': beatPhase < 0.1}" style="margin-left: 8px;">
                <span class="dot"></span>
                {{ audio.bpm }} BPM
              </span>
            </div>
            <div class="chips" style="margin-top:6px;">
              <span class="chip">Re-detect</span>
              <span class="chip">Tap tempo</span>
              <span class="chip">Add tempo change</span>
            </div>
          </div>
          <div class="rack" v-if="audio.uploadedFile">
            <h3>Modulation Router</h3>
            <div class="compact-panel">
              <div class="mod-header">
                <span>Audio ‚Üí Parameter mapping</span>
                <div class="chips">
                  <span class="chip" @click="addAudioMapping" v-if="audioMappings.length<8">+ Add</span>
                  <span class="chip" @click="runAudioMod">Send audio map</span>
                </div>
              </div>
              <div class="compact-grid">
                <div class="audio-map-card" v-for="(m, idx) in audioMappings" :key="'map'+idx">
                  <div class="meta">Target</div>
                  <select v-model="m.param">
                    <option value="">(none)</option>
                    <optgroup v-for="group in lfoTargetGroups" :key="'amap'+group.label" :label="group.label">
                      <option v-for="t in group.items" :key="'amap'+t.key" :value="t.key">{{ t.label }}</option>
                    </optgroup>
                  </select>
                  <div class="slider-row" style="margin-top:6px;">
                    <div>Freq min</div><input type="number" min="0" step="10" v-model.number="m.freq_min">
                  </div>
                  <div class="slider-row">
                    <div>Freq max</div><input type="number" min="0" step="10" v-model.number="m.freq_max">
                  </div>
                  <div class="slider-row">
                    <div>Out min</div><input type="number" step="0.01" v-model.number="m.out_min">
                  </div>
                  <div class="slider-row">
                    <div>Out max</div><input type="number" step="0.01" v-model.number="m.out_max">
                  </div>
                  <div class="chips" style="margin-top:6px;">
                    <span class="chip" @click="removeAudioMapping(idx)">Remove</span>
                  </div>
                </div>
              </div>
              <div class="meta">Upload an audio file above to drive these mappings. Status: {{ audioStatus }}</div>
            </div>
            <div class="compact-panel">
              <div class="mod-header">
                <span>LFO ‚Üí Parameter mapping</span>
                <div class="chips">
                  <span class="chip" @click="addLfo">‚ûï Add LFO</span>
                </div>
              </div>
              <div class="slider-row">
                <div>Global BPM</div>
                <input class="select" type="number" min="20" max="240" step="1" v-model.number="lfoBpm">
              </div>
              <div class="mod-row" v-for="(l, idx) in lfos" :key="l.id">
                <div class="switch" @click="l.on=!l.on">
                  <span class="dot" :style="{background: l.on ? 'var(--success)' : '#444'}"></span>
                </div>
                <select class="select" v-model="l.target" @change="initLfoBase(l)">
                  <option value="">Target</option>
                  <optgroup v-for="group in lfoTargetGroups" :key="'lfo'+group.label" :label="group.label">
                    <option v-for="t in group.items" :key="'lfo'+t.key" :value="t.key">{{ t.label }}</option>
                  </optgroup>
                </select>
                <select class="select" v-model="l.shape">
                  <option v-for="s in lfoShapes" :key="s">{{ s }}</option>
                </select>
                <input type="number" min="20" max="240" step="1" v-model.number="l.bpm" title="BPM">
                <input type="number" :min="lfoTarget(l) ? lfoTarget(l).min : 0" :max="lfoTarget(l) ? lfoTarget(l).max : 1" step="0.01" v-model.number="l.base" title="Base">
                <input type="range" min="0" max="1" step="0.01" v-model.number="l.depth" title="Depth">
                <button @click="removeLfo(idx)">‚úï</button>
              </div>
              <div class="mod-row" v-for="l in lfos" :key="'preview'+l.id">
                <div></div>
                <div class="mod-preview">
                  <svg viewBox="0 0 120 36" preserveAspectRatio="none">
                    <path v-if="l.shape==='Sine'" d="M0 18 C 15 0, 30 36, 45 18 S 75 0, 90 18 S 105 36, 120 18" fill="none" stroke="#2de2ff" stroke-width="2"/>
                    <path v-else-if="l.shape==='Triangle'" d="M0 28 L30 6 L60 28 L90 6 L120 28" fill="none" stroke="#2de2ff" stroke-width="2"/>
                    <path v-else-if="l.shape==='Saw'" d="M0 28 L120 6" fill="none" stroke="#2de2ff" stroke-width="2"/>
                    <path v-else-if="l.shape==='Square'" d="M0 28 L0 6 L60 6 L60 28 L120 28" fill="none" stroke="#2de2ff" stroke-width="2"/>
                    <path v-else d="M0 26 L15 18 L30 30 L45 10 L60 26 L75 16 L90 30 L105 12 L120 26" fill="none" stroke="#2de2ff" stroke-width="2"/>
                  </svg>
                </div>
              </div>
              <div class="mod-subheader">Beat macros (beat-synced modulation)</div>
              <div class="compact-grid">
                <div v-for="(m, idx) in macrosRack" :key="'mac'+idx" class="audio-map-card">
                  <div style="display:flex; gap:6px; align-items:center; justify-content:space-between;">
                    <span>Macro {{ idx+1 }}</span>
                    <span class="chip" @click="m.on=!m.on">{{ m.on ? 'ON' : 'OFF' }}</span>
                  </div>
                  <div class="slider-row"><div>Target</div><select class="select" v-model="m.target"><option>Vibe (CFG)</option><option>Zoom</option><option>Noise</option></select></div>
                  <div class="slider-row"><div>Shape</div><select class="select" v-model="m.shape"><option>Sine</option><option>Saw</option><option>Noise</option></select></div>
                  <div class="slider-row"><div>Speed</div><select class="select" v-model="m.speed"><option>1/4 note</option><option>1 bar</option><option>1/8 note</option></select></div>
                  <div class="slider-row"><div>Depth</div><input type="range" min="0" max="1" step="0.01" v-model.number="m.depth"></div>
                  <div class="slider-row"><div>Offset</div><input type="range" min="-1" max="1" step="0.01" v-model.number="m.offset"></div>
                  <div class="chips"><span class="chip" @click="m.show=true">Show in graph</span></div>
                </div>
              </div>
              <div class="chips">
                <span class="chip" @click="addMacro" v-if="macrosRack.length<6">+ Add macro</span>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='FEATURES'">
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">Waveform Preview</div>
                <div class="pill">LFO Enabled</div>
              </div>
              <div class="framesync-graph">
                <svg viewBox="0 0 820 140" width="100%" height="140" preserveAspectRatio="none">
                  <path d="M0 70 C 80 10, 160 130, 240 70 S 400 10, 480 70 S 640 130, 720 70 S 800 10, 820 70" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                  <line x1="0" y1="70" x2="820" y2="70" stroke="#0c3048" stroke-width="1"/>
                </svg>
                <div class="framesync-axis">
                  <span v-for="n in 12" :key="'axis-'+n">{{ (n-1) * 10 }}</span>
                </div>
              </div>
            </div>
          </div>
          <div class="framesync-row">
            <div class="framesync-stack">
              <div class="framesync-panel">
                <div class="framesync-subtitle">Animation Presets</div>
                <select class="framesync-select" v-model="framesync.selectedPreset">
                  <option v-for="preset in framesync.presets" :key="preset" :value="preset">{{ preset }}</option>
                </select>
                <div class="framesync-list" style="margin-top:8px;">
                  <div class="item" v-for="preset in framesync.factoryPresets" :key="'factory-'+preset">‚ñ∏ {{ preset }}</div>
                </div>
                <div class="framesync-footer">
                  <button class="framesync-button">Save preset</button>
                  <button class="framesync-button">Import presets</button>
                  <button class="framesync-button">Export presets</button>
                </div>
              </div>
              <div class="framesync-panel">
                <div class="framesync-subtitle">Lock</div>
                <div class="framesync-toggle"><span class="framesync-dot"></span> Lock Frame Count</div>
                <div class="framesync-toggle"><span class="framesync-dot"></span> Lock Frame Rate</div>
                <div class="framesync-toggle"><span class="framesync-dot"></span> Lock Tempo</div>
              </div>
            </div>
            <div class="framesync-stack">
              <div class="framesync-panel">
                <div class="framesync-subtitle">Wave Settings</div>
                <div class="slider-row">
                  <div>Audio file</div>
                  <input type="file" class="framesync-input" />
                </div>
                <div class="slider-row">
                  <div>Primary Wave</div>
                  <select class="framesync-select" v-model="framesync.primaryWave">
                    <option v-for="shape in framesync.waveShapes" :key="shape">{{ shape }}</option>
                  </select>
                </div>
                <div class="framesync-wave-shapes">
                  <div class="framesync-wave" v-for="shape in framesync.waveShapes" :key="'wave-'+shape">
                    <svg viewBox="0 0 60 40">
                      <path v-if="shape==='Sine' || shape==='Cosine'" d="M0 20 C 10 0, 20 40, 30 20 S 50 0, 60 20" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                      <path v-else-if="shape==='Saw'" d="M0 35 L60 5" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                      <path v-else-if="shape==='Triangle'" d="M0 30 L30 5 L60 30" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                      <path v-else-if="shape==='Square'" d="M0 30 L0 5 L30 5 L30 30 L60 30" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                      <path v-else d="M0 28 L10 18 L20 30 L30 10 L40 26 L50 16 L60 30" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                    </svg>
                    {{ shape }}
                  </div>
                </div>
                <div class="slider-row">
                  <div>Amplitude</div>
                  <input type="number" class="framesync-input" v-model.number="framesync.amplitude" />
                </div>
                <div class="slider-row">
                  <div>Shift</div>
                  <input type="number" class="framesync-input" v-model.number="framesync.shift" />
                </div>
                <div class="slider-row">
                  <div>Bend</div>
                  <input type="number" class="framesync-input" v-model.number="framesync.bend" />
                </div>
                <div class="slider-row">
                  <div>Noise</div>
                  <input type="number" class="framesync-input" v-model.number="framesync.noise" />
                </div>
                <div class="framesync-toggle" style="margin-top:6px;"><span class="framesync-dot"></span> Enable LFO Modulator</div>
              </div>
            </div>
            <div class="framesync-stack">
              <div class="framesync-panel">
                <div class="framesync-subtitle">Frame Settings</div>
                <div class="slider-row">
                  <div>Frame Rate (FPS)</div>
                  <input type="number" class="framesync-input" v-model.number="framesync.fps" />
                </div>
                <div class="slider-row">
                  <div>Frame Count</div>
                  <input type="number" class="framesync-input" v-model.number="framesync.frameCount" />
                </div>
                <div class="framesync-subtitle" style="margin-top:8px;">Sync Settings</div>
                <div class="slider-row">
                  <div>Tempo (BPM)</div>
                  <input type="number" class="framesync-input" v-model.number="framesync.bpm" />
                </div>
                <div class="slider-row">
                  <div>Shift Left/Right</div>
                  <input type="number" class="framesync-input" v-model.number="framesync.shiftFrames" />
                </div>
                <div class="framesync-subtitle" style="margin-top:8px;">Sync Rate</div>
                <div class="framesync-buttons">
                  <button class="framesync-button" v-for="rate in framesync.syncRates" :key="rate" :class="{active: framesync.syncRate===rate}" @click="framesync.syncRate = rate">{{ rate }}</button>
                </div>
                <div class="framesync-subtitle" style="margin-top:8px;">Decimal Places</div>
                <input type="number" class="framesync-input" v-model.number="framesync.decimals" />
              </div>
            </div>
            <div class="framesync-stack">
              <div class="framesync-panel">
                <div class="framesync-subtitle">Metrics</div>
                <div class="framesync-metric" v-for="metric in framesync.metrics" :key="metric.label">
                  <div>{{ metric.label }}</div>
                  <div>
                    {{ metric.value }}
                    <span>{{ metric.sub }}</span>
                  </div>
                </div>
                <div class="framesync-subtitle" style="margin-top:10px;">Timing Table</div>
                <div class="framesync-list">
                  <div class="item" v-for="row in framesync.timingTable" :key="row.label">
                    {{ row.label }} ¬∑ {{ row.time }} ¬∑ {{ row.frames }}
                  </div>
                </div>
              </div>
              <div class="framesync-panel">
                <div class="framesync-subtitle">Feature Coverage</div>
                <div class="framesync-list">
                  <div class="item" v-for="feature in framesync.featureCoverage" :key="feature">‚Ä¢ {{ feature }}</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='CONTROLNET'">
          <div class="rack">
            <h3>ControlNet slots</h3>
            <div class="chips">
              <span class="chip" v-for="slot in cn.slots" :key="slot.id" :class="{active: cn.active===slot.id}" @click="cn.active=slot.id">{{ slot.label }}</span>
              <span class="chip" @click="loadControlNetModels">üîÑ Refresh models</span>
            </div>
          </div>
          <div class="rack">
            <h3>{{ activeSlot.label }}</h3>
            <div class="slider-row">
              <div>Model</div>
              <select class="select" v-model="activeSlot.model" @change="updateControlNet(activeSlot)">
                <option v-for="m in cn.availableModels" :key="m.id" :value="m.name">{{ m.name }}</option>
              </select>
            </div>
            <div class="chips" style="margin-bottom:8px;">
              <span class="chip" @click="uploadControlNetImage(activeSlot)">üìÅ Change image</span>
              <span class="chip" :class="{active: activeSlot.enabled}" @click="activeSlot.enabled=!activeSlot.enabled; updateControlNet(activeSlot)">{{ activeSlot.enabled ? 'Enabled' : 'Disabled' }}</span>
            </div>
            <div class="slider-row">
              <div>Weight</div>
              <input type="range" min="0" max="2" step="0.01" v-model.number="activeSlot.weight" @input="updateControlNet(activeSlot)">
              <span style="margin-left:8px; color:var(--muted); font-size:12px;">{{ activeSlot.weight.toFixed(2) }}</span>
            </div>
            <div class="slider-row">
              <div>Start</div>
              <input type="range" min="0" max="1" step="0.01" v-model.number="activeSlot.start" @input="updateControlNet(activeSlot)">
              <span style="margin-left:8px; color:var(--muted); font-size:12px;">{{ activeSlot.start.toFixed(2) }}</span>
            </div>
            <div class="slider-row">
              <div>End</div>
              <input type="range" min="0" max="1" step="0.01" v-model.number="activeSlot.end" @input="updateControlNet(activeSlot)">
              <span style="margin-left:8px; color:var(--muted); font-size:12px;">{{ activeSlot.end.toFixed(2) }}</span>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='SETTINGS'">
          <div class="rack">
            <h3>Engine</h3>
            <div class="slider-row"><div>Resolution</div><select class="select"><option>1024x576</option><option>1280x720</option></select></div>
            <div class="slider-row"><div>FPS</div><select class="select"><option>24</option><option selected>30</option><option>60</option></select></div>
            <div class="slider-row"><div>Steps</div><select class="select"><option>24</option><option>30</option><option>40</option></select></div>
            <div class="chips">
              <span class="chip">Seed: 42490527</span>
              <span class="chip">Sampler: DPM++ 2M Karras</span>
            </div>
          </div>
          <div class="rack">
            <h3>Controllers (WebMIDI)</h3>
            <div v-if="!midi.supported" style="color:var(--muted);">WebMIDI not supported or not enabled.</div>
            <div v-else>
              <div class="chips" style="margin-bottom:6px;">
                <span class="chip" v-for="d in midi.devices" :key="d.id" :class="{active: midi.selected===d.id}" @click="midi.selected=d.id">{{ d.name }}</span>
                <span class="chip" @click="scanMidi()">Rescan</span>
              </div>
              <div class="chips">
                <span class="chip">Learn mode</span>
                <span class="chip" @click="addMidiMapping">+ Add Mapping</span>
                <span class="chip">Status: {{ midiStatus }}</span>
              </div>
              <table class="table">
                <thead><tr><th>Control</th><th>CC</th><th>Target</th><th>Actions</th></tr></thead>
                <tbody>
                  <tr v-for="(m, idx) in midi.mappings" :key="'midi'+idx">
                    <td><input class="select" v-model="m.control" @change="saveMidiMappings" style="width:100px;"></td>
                    <td><input class="select" type="number" v-model.number="m.cc" @change="saveMidiMappings" style="width:60px;"></td>
                    <td>
                      <select class="select" v-model="m.key" @change="saveMidiMappings" style="width:120px;">
                        <option value="">None</option>
                        <option v-for="t in lfoTargets" :key="'mopt'+t.key" :value="t.key">{{ t.label }}</option>
                      </select>
                    </td>
                    <td><span class="chip" @click="deleteMidiMapping(idx)" style="cursor:pointer;">Delete</span></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="rack">
            <h3>Preset Management</h3>
            <div class="chips" style="margin-bottom:8px;">
              <span class="chip" v-for="p in availablePresets" :key="p" :class="{active: currentPreset===p}" @click="loadPreset(p)">{{ p }}</span>
              <span class="chip" @click="refreshPresets">üîÑ Refresh</span>
            </div>
            <div class="slider-row">
              <div>New preset name</div>
              <input class="select" v-model="newPresetName" placeholder="my-preset" style="flex:1;">
            </div>
            <div class="chips">
              <span class="chip" @click="saveCurrentPreset">üíæ Save current as preset</span>
              <span class="chip" v-if="currentPreset" @click="deletePreset(currentPreset)" style="color:var(--danger);">üóë Delete {{ currentPreset }}</span>
            </div>
            <div v-if="presetStatus" style="font-size:12px; color:var(--muted); margin-top:6px;">{{ presetStatus }}</div>
          </div>
        </div>
      </div>

      <!-- Bottom context panel -->
      <div class="context">
        <div v-if="currentTab==='LIVE'">
          <h4>Beat & MIDI status</h4>
          <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="min-width:240px;">
              <strong>Beat macros ({{ macrosRack.length }})</strong>
              <div v-for="m in macrosRack" :key="m.target" style="font-size:12px; color:var(--muted);">
                ‚Ä¢ {{ m.target }} ‚Äì {{ m.shape }} @ {{ m.speed }} ‚Äì Depth {{ (m.depth*100).toFixed(0) }}%
              </div>
            </div>
            <div style="min-width:240px;">
              <strong>MIDI mappings</strong>
              <div style="font-size:12px; color:var(--muted);">
                ‚Ä¢ LaunchControl CC21 ‚Üí Vibe<br/>
                ‚Ä¢ LaunchControl CC22 ‚Üí Strength<br/>
                ‚Ä¢ LaunchControl CC23 ‚Üí Zoom
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='PROMPTS'">
          <h4>Morph slots</h4>
          <table class="table">
            <thead><tr><th>ID</th><th>On</th><th>Name</th><th>A prompt</th><th>B prompt</th><th>Range</th></tr></thead>
            <tbody>
              <tr v-for="slot in morphSlots" :key="slot.id">
                <td>{{ slot.id }}</td>
                <td>{{ slot.on ? '‚óè' : '‚óã' }}</td>
                <td>{{ slot.name }}</td>
                <td>{{ slot.a }}</td>
                <td>{{ slot.b }}</td>
                <td>{{ slot.range }}</td>
              </tr>
            </tbody>
          </table>
          <div class="chips"><span class="chip">+ Add morph</span><span class="chip">Copy from preset</span></div>
        </div>

        <div v-else-if="currentTab==='MOTION'">
          <h4>Camera curves</h4>
          <div class="wave" style="height:100px; background:#11182a; margin-bottom:8px;"></div>
          <div style="font-size:12px; color:var(--muted);">Pan X/Y and Zoom curves over beats. Tools: Apply Sine/Saw, Smooth, Snap to Beats.</div>
        </div>

        <div v-else-if="currentTab==='AUDIO'">
          <h4>Active macro curve</h4>
          <div class="wave" style="height:120px; background:#11182a; margin-bottom:8px;"></div>
          <div class="chips">
            <span class="chip">‚ó† Sine</span><span class="chip">‚ñ≥ Triangle</span><span class="chip">/ Saw</span><span class="chip">‚ß† Square</span><span class="chip">~ Noise</span><span class="chip">‚ô´ From audio peaks</span>
          </div>
        </div>

        <div v-else-if="currentTab==='FEATURES'">
          <h4>Feature coverage</h4>
          <div class="chips">
            <span class="chip" v-for="feature in framesync.featureCoverage" :key="'ctx-'+feature">{{ feature }}</span>
          </div>
        </div>

        <div v-else-if="currentTab==='CONTROLNET'">
          <h4>Drive parameters</h4>
          <div class="chips">
            <span class="chip">Vibe / CFG</span><span class="chip">Camera pan</span><span class="chip">Zoom pulses</span><span class="chip">Noise / Glitch</span>
          </div>
        </div>

        <div v-else-if="currentTab==='SETTINGS'">
          <h4>MIDI mappings</h4>
          <table class="table">
            <thead><tr><th>Source</th><th>Target</th><th>Mode</th><th>Curve</th></tr></thead>
            <tbody>
              <tr v-for="m in midi.mappings" :key="m.control+'ctx'">
                <td>{{ m.control || ('CC '+m.cc) }}</td>
                <td>
                  <select class="select" v-model="m.key" @change="updateMidiMapping(m)">
                    <option value="">(none)</option>
                    <option v-for="t in lfoTargets" :key="'map'+t.key" :value="t.key">{{ t.label }}</option>
                  </select>
                </td>
                <td>Absolute</td>
                <td>Linear</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          session: "clown_set_01",
          tabs: [
            { id: "LIVE", label: "LIVE" },
            { id: "PROMPTS", label: "PROMPTS" },
            { id: "MOTION", label: "MOTION" },
            { id: "AUDIO", label: "AUDIO/BEATS" },
            { id: "FEATURES", label: "FEATURES" },
            { id: "CONTROLNET", label: "CN" },
            { id: "SETTINGS", label: "SETTINGS" },
          ],
          currentTab: "LIVE",
          stats: { fps: 27, lat: 120 },
          hud: { seed: 42490527 },
          timecode: "00:00.00",
          liveVibe: [
            { key: "cfg", label: "Vibe (CFG)", val: 0.63, min: 0, max: 1.5, step: 0.01 },
            { key: "strength", label: "Strength", val: 0.78, min: 0, max: 1.5, step: 0.01 },
            { key: "noise", label: "Noise/Glitch", val: 0.2, min: 0, max: 1, step: 0.01 },
            { key: "cfgscale", label: "CFG scale", val: 5.0, min: 0, max: 15, step: 0.1 },
          ],
          liveCam: [
            { key: "zoom", label: "Zoom", val: 0.8, min: -5, max: 5, step: 0.05, sourceable: true },
            { key: "panx", label: "Pan X", val: 0.1, min: -1, max: 1, step: 0.05, sourceable: false },
            { key: "pany", label: "Pan Y", val: 0.0, min: -1, max: 1, step: 0.05, sourceable: false },
            { key: "tilt", label: "Tilt / Rotate", val: 0.0, min: -180, max: 180, step: 0.5, sourceable: false },
          ],
          paramSources: {
            cfg: "Manual",
            strength: "Manual",
            noise: "Beat",
            cfgscale: "Manual",
            zoom: "Beat",
          },
          prompts: { pos: "", neg: "", morphOn: true },
          morphSlots: [
            { id: 1, on: true, name: "clean ‚Üí mad", a: "clean evil", b: "mad clown", range: "0.40‚Äì1.00" },
            { id: 2, on: true, name: "box ‚Üí tunnel", a: "small box", b: "neon tunnel", range: "0.00‚Äì0.60" },
            { id: 3, on: false, name: "style fade", a: "photographic", b: "anime render", range: "0.20‚Äì0.80" },
          ],
          motionPresets: {
            Static: { translation_z: 0, translation_x: 0, translation_y: 0, rotation_z: 0, rotation_y: 0 },
            Orbit: { translation_z: 2, rotation_y: 15, translation_x: 0, translation_y: 0, rotation_z: 0 },
            Tunnel: { translation_z: 5, translation_x: 0, translation_y: 0, rotation_z: 0, rotation_y: 0 },
            Handheld: { translation_z: 0.5, translation_x: 0.2, translation_y: 0.1, rotation_z: 2, rotation_y: 0 },
            Chaos: { translation_z: 1.5, translation_x: 0.5, translation_y: 0.3, rotation_z: 5, rotation_y: 10 }
          },
          motionStyles: ["Calm", "Travel", "Spin", "Handheld", "Chaos"],
          xyPad: { x: 0, y: 0, dragging: false, padSize: 140 },
          audio: { track: "", bpm: 114.8, uploadedFile: null },
          audioStatus: "Idle",
          audioMappings: [
            { param: "strength", freq_min: 20, freq_max: 300, out_min: 0, out_max: 1.5 },
            { param: "cfg", freq_min: 300, freq_max: 1200, out_min: 0, out_max: 30 },
            { param: "translation_z", freq_min: 1200, freq_max: 3000, out_min: -5, out_max: 5 },
          ],
          lfoBpm: 120,
          lfoTargets: [
            { key: "cfg", label: "Vibe (CFG)", min: 0, max: 30, default: 6, group: "Style" },
            { key: "strength", label: "Strength", min: 0, max: 1.5, default: 0.7, group: "Style" },
            { key: "noise_multiplier", label: "Noise/Glitch", min: 0, max: 3, default: 1.0, group: "Style" },
            { key: "translation_z", label: "Zoom", min: -10, max: 10, default: 0, group: "Camera" },
            { key: "translation_x", label: "Pan X", min: -10, max: 10, default: 0, group: "Camera" },
            { key: "translation_y", label: "Pan Y", min: -10, max: 10, default: 0, group: "Camera" },
            { key: "rotation_y", label: "Rotate Y", min: -180, max: 180, default: 0, group: "Camera" },
            { key: "rotation_z", label: "Tilt", min: -180, max: 180, default: 0, group: "Camera" },
            { key: "fov", label: "FOV", min: 1, max: 180, default: 70, group: "Camera" },
          ],
          lfoShapes: ["Sine", "Triangle", "Saw", "Square"],
          lfos: Array.from({ length: 6 }).map((_, idx) => ({
            id: idx + 1,
            on: idx === 0,
            target: idx === 0 ? "cfg" : "",
            shape: "Sine",
            bpm: 120,
            depth: 0.1,
            base: null,
            phase: 0,
          })),
          macrosRack: [
            { on: true, target: "Vibe (CFG)", shape: "Sine", speed: "1/4 note", depth: 0.7, offset: 0.1, show: true },
            { on: true, target: "Zoom", shape: "Saw", speed: "1 bar", depth: 0.6, offset: 0.2, show: false },
            { on: false, target: "Noise/Glitch", shape: "Noise", speed: "1/8 note", depth: 0.3, offset: 0.0, show: false },
            ],
          framesync: {
            presets: ["Basic Strength Schedule", "Basic Noise Schedule", "Basic Init"],
            factoryPresets: ["Basic Strength Schedule", "Basic Noise Schedule", "Basic Init"],
            selectedPreset: "Basic Strength Schedule",
            primaryWave: "Cosine",
            waveShapes: ["Cosine", "Sine", "Saw", "Triangle", "Square", "Noise"],
            amplitude: 1,
            shift: 0,
            bend: 1,
            noise: 0,
            fps: 24,
            frameCount: 120,
            bpm: 120,
            shiftFrames: 0,
            syncRates: ["1", "1/2", "1/4", "1/8", "1/16", "1/32", "2", "4", "8"],
            syncRate: "1/4",
            decimals: 2,
            metrics: [
              { label: "Max", value: "1.00", sub: "32bars" },
              { label: "Min", value: "-1.00", sub: "16bars" },
              { label: "Avg", value: "0.00", sub: "4bars" },
              { label: "Abs Avg", value: "0.63", sub: "1bar" },
              { label: "Duration", value: "5.00s", sub: "1/2" },
            ],
            timingTable: [
              { label: "32bar", time: "58.0s", frames: "1392.0" },
              { label: "16bar", time: "28.0s", frames: "768.0" },
              { label: "8bar", time: "16.0s", frames: "384.0" },
              { label: "4bar", time: "8.0s", frames: "192.0" },
              { label: "2bar", time: "4.0s", frames: "96.0" },
              { label: "1bar", time: "2.0s", frames: "48.0" },
              { label: "1/2", time: "1.0s", frames: "24.0" },
            ],
            featureCoverage: [
              "Wave presets",
              "LFO modulation",
              "Audio-driven sync",
              "Tempo & shift",
              "Metrics + timing table",
              "Preset import/export"
            ],
          },
          cn: {
            slots: [
              { id: "CN1", label: "CN1", model: "Canny", weight: 0.4, start: 0, end: 0.9, enabled: false },
              { id: "CN2", label: "CN2 ‚Ä¢", model: "Depth", weight: 0.4, start: 0, end: 0.9, enabled: true },
              { id: "CN3", label: "CN3", model: "Pose", weight: 0.4, start: 0, end: 0.9, enabled: false },
              { id: "CN4", label: "CN4", model: "Tile", weight: 0.4, start: 0, end: 0.9, enabled: false },
              { id: "CN5", label: "CN5", model: "Control", weight: 0.4, start: 0, end: 0.9, enabled: false },
            ],
            active: "CN2",
            availableModels: [],
          },
          midi: {
            supported: !!navigator.requestMIDIAccess,
            devices: [],
            selected: null,
            mappings: [
              { control: "LaunchControl CC21", cc: 21, key: "cfg" },
              { control: "LaunchControl CC22", cc: 22, key: "strength" },
              { control: "LaunchControl CC23", cc: 23, key: "cfgscale" },
            ],
          },
          midiStatus: "Ready",
          ws: null,
          wsStatus: "disconnected",
          streamSrc: "/hls/live/deforum.m3u8",
          thumbs: [],
          framesTimer: null,
          playerEl: null,
          timeHandler: null,
          hls: null,
          liveParamTimers: {},
          liveParamPending: {},
          lastParamSent: {},
          controlDelayMs: 75,
          errorHandler: null,
          playbackTimer: null,
          lfoTimer: null,
          lastLfoTick: null,
          beatTimer: null,
          lastBeatTime: null,
          beatCount: 0,
          beatPhase: 0,
          availablePresets: [],
          currentPreset: null,
          newPresetName: "",
          presetStatus: "",
        };
      },
      computed: {
        activeSlot() {
          return this.cn.slots.find((s) => s.id === this.cn.active) || this.cn.slots[0];
        },
        lfoTargetGroups() {
          const groups = {};
          this.lfoTargets.forEach((target) => {
            const label = target.group || "Other";
            if (!groups[label]) groups[label] = [];
            groups[label].push(target);
          });
          return Object.entries(groups).map(([label, items]) => ({ label, items }));
        },
      },
      mounted() {
        this.attachPlayer();
        this.setupWS();
        this.scanMidi();
        this.refreshFrames();
        this.refreshPresets();
        this.loadControlNetModels();
        if (typeof fetch === "function") {
          this.framesTimer = setInterval(() => this.refreshFrames(), 5000);
        }
        this.playbackTimer = setInterval(() => this.ensureLivePlayback(), 4000);
        this.lfoTimer = setInterval(() => this.runLfos(), 120);
        this.beatTimer = setInterval(() => this.processBeat(), 50);
      },
      beforeUnmount() {
        if (this.framesTimer) clearInterval(this.framesTimer);
        if (this.playbackTimer) clearInterval(this.playbackTimer);
        if (this.lfoTimer) clearInterval(this.lfoTimer);
        if (this.beatTimer) clearInterval(this.beatTimer);
        if (this.playerEl && this.timeHandler) {
          this.playerEl.removeEventListener("timeupdate", this.timeHandler);
        }
        if (this.playerEl && this.errorHandler) {
          this.playerEl.removeEventListener("error", this.errorHandler);
        }
      },
      methods: {
        switchTab(id) {
          this.currentTab = id;
        },
        attachPlayer() {
          const video = document.getElementById("player");
          if (!video) return;
          if (this.playerEl && this.timeHandler) this.playerEl.removeEventListener("timeupdate", this.timeHandler);
          if (this.playerEl && this.errorHandler) this.playerEl.removeEventListener("error", this.errorHandler);
          this.playerEl = video;
          const hlsSource = this.streamSrc.includes("?") ? this.streamSrc + "&t=" + Date.now() : this.streamSrc + "?t=" + Date.now();
          if (this.hls && this.hls.destroy) {
            this.hls.destroy();
            this.hls = null;
          }
          if (video.canPlayType("application/vnd.apple.mpegurl")) {
            video.src = hlsSource;
            video.load();
            this.autoplayVideo(video);
          } else if (typeof Hls !== "undefined" && Hls.isSupported && Hls.isSupported()) {
            const hlsEvents = (Hls && Hls.Events) || { MANIFEST_PARSED: "manifest_parsed", ERROR: "error" };
            this.hls = new Hls({ liveSyncDurationCount: 3 });
            this.hls.loadSource(hlsSource);
            this.hls.attachMedia(video);
            if (this.hls.on) {
              this.hls.on(hlsEvents.MANIFEST_PARSED, () => this.autoplayVideo(video));
              this.hls.on(hlsEvents.ERROR, () => {
                setTimeout(() => this.attachPlayer(), 800);
              });
            }
          } else {
            video.src = hlsSource;
          }
          this.timeHandler = () => {
            if (!isNaN(video.currentTime)) {
              const t = video.currentTime;
              const m = Math.floor(t / 60);
              const s = (t % 60).toFixed(2).padStart(5, "0");
              this.timecode = `${String(m).padStart(2, "0")}:${s}`;
            }
          };
          this.errorHandler = () => {
            setTimeout(() => this.attachPlayer(), 800);
          };
          video.addEventListener("timeupdate", this.timeHandler);
          video.addEventListener("error", this.errorHandler);
          this.autoplayVideo(video);
        },
        autoplayVideo(video) {
          const el = video || this.playerEl;
          if (!el || typeof el.play !== "function") return;
          const p = el.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
        },
        ensureLivePlayback() {
          if (!this.playerEl) return;
          if (this.playerEl.paused || this.playerEl.readyState < 2) {
            this.autoplayVideo(this.playerEl);
          }
        },
        lfoTarget(lfo) {
          if (!lfo || !lfo.target) return null;
          return this.lfoTargets.find((t) => t.key === lfo.target) || null;
        },
        initLfoBase(lfo) {
          const target = this.lfoTarget(lfo);
          if (!target) return;
          if (lfo.base === null || lfo.base === undefined) {
            lfo.base = target.default != null ? target.default : (target.min + target.max) / 2;
          } else {
            lfo.base = this.clampVal(lfo.base, target.min, target.max);
          }
        },
        shapeValue(shape, phase) {
          const p = phase % (Math.PI * 2);
          if (shape === "Square") return Math.sin(p) >= 0 ? 1 : -1;
          if (shape === "Saw") return p / Math.PI - 1; // -1..1
          if (shape === "Triangle") return (2 * Math.asin(Math.sin(p))) / Math.PI;
          return Math.sin(p);
        },
        clampVal(v, min, max) {
          if (v === null || v === undefined || Number.isNaN(v)) return min;
          return Math.min(max, Math.max(min, v));
        },
        getNow() {
          return (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
        },
        runLfos(now = this.getNow()) {
          if (this.audio.track) return; // audio sync takes over
          if (this.lastLfoTick === null) {
            this.lastLfoTick = now;
            return;
          }
          const dtSec = (now - this.lastLfoTick) / 1000;
          this.lastLfoTick = now;
          if (dtSec <= 0) return;

          const payload = {};
          this.lfos.forEach((lfo) => {
            if (!lfo.on || !lfo.target) return;
            const target = this.lfoTarget(lfo);
            if (!target) return;
            const bpm = lfo.bpm || this.lfoBpm || 120;
            const depth = this.clampVal(lfo.depth ?? 0, 0, 1);
            const base = lfo.base == null ? (target.default ?? (target.min + target.max) / 2) : this.clampVal(lfo.base, target.min, target.max);
            lfo.base = base;
            const inc = dtSec * (bpm / 60) * Math.PI * 2;
            const phase = (lfo.phase || 0) + inc;
            lfo.phase = phase % (Math.PI * 2);
            const wave = this.shapeValue(lfo.shape, lfo.phase);
            const amp = depth * (target.max - target.min) / 2;
            const value = this.clampVal(base + wave * amp, target.min, target.max);
            payload[target.key] = value;
          });
          if (Object.keys(payload).length) {
            this.sendControl("liveParam", payload);
          }
        },
        processBeat() {
          const now = this.getNow();
          const bpm = this.audio.bpm || 120;
          const beatIntervalMs = (60 / bpm) * 1000;
          
          if (this.lastBeatTime === null) {
            this.lastBeatTime = now;
            this.beatCount = 0;
            this.beatPhase = 0;
            return;
          }
          
          const timeSinceLastBeat = now - this.lastBeatTime;
          
          // Check if a beat should occur
          if (timeSinceLastBeat >= beatIntervalMs) {
            this.lastBeatTime = now;
            this.beatCount++;
            this.triggerBeatMacros();
          }
          
          // Update continuous beat phase for smooth animations
          this.beatPhase = (timeSinceLastBeat / beatIntervalMs) % 1;
        },
        triggerBeatMacros() {
          const payload = {};
          const activeMacros = this.macrosRack.filter(m => m.on);
          
          activeMacros.forEach(macro => {
            const target = this.lfoTargets.find(t => t.label === macro.target || t.key === macro.target);
            if (!target) return;
            
            // Determine if this macro should trigger on this beat
            const shouldTrigger = this.shouldMacroTrigger(macro);
            if (!shouldTrigger) return;
            
            // Calculate value based on macro shape
            const base = target.default ?? (target.min + target.max) / 2;
            const depth = this.clampVal(macro.depth ?? 0.5, 0, 1);
            const offset = this.clampVal(macro.offset ?? 0, -1, 1);
            
            let value;
            if (macro.shape === "Noise") {
              // Random value for noise
              value = base + (Math.random() * 2 - 1) * depth * (target.max - target.min) / 2;
            } else {
              // Use shape value at current phase
              const phase = this.beatPhase * Math.PI * 2;
              const wave = this.shapeValue(macro.shape || "Sine", phase);
              value = base + (wave + offset) * depth * (target.max - target.min) / 2;
            }
            
            payload[target.key] = this.clampVal(value, target.min, target.max);
          });
          
          if (Object.keys(payload).length) {
            this.sendControl("liveParam", payload);
          }
        },
        shouldMacroTrigger(macro) {
          const speed = macro.speed || "1/4 note";
          
          // Parse the speed to determine trigger frequency
          if (speed === "1/4 note") {
            // Trigger every beat
            return true;
          } else if (speed === "1/8 note") {
            // NOTE: Currently triggers every beat like 1/4 note
            // TODO: Implement proper 1/8 note timing (requires sub-beat timing)
            // For proper 1/8 notes, would need to trigger at beat + half-beat intervals
            return true;
          } else if (speed === "1 bar") {
            // Trigger every 4 beats (assuming 4/4 time)
            return this.beatCount % 4 === 0;
          } else if (speed === "2 bars") {
            // Trigger every 8 beats
            return this.beatCount % 8 === 0;
          }
          
          return true;
        },
        setupWS() {
          const url = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws";
          const connect = () => {
            this.ws = new WebSocket(url);
            this.ws.onopen = () => {
              this.wsStatus = "connected";
              console.log("WS connected");
            };
            this.ws.onclose = () => {
              this.wsStatus = "disconnected";
              setTimeout(connect, 1000);
            };
            this.ws.onmessage = (evt) => {
              try {
                const msg = JSON.parse(evt.data);
                if (msg.type === "event") console.log(msg.msg || "event");
                if (msg.type === "stream" && msg.src) {
                  this.streamSrc = msg.src + "?t=" + Date.now();
                  this.attachPlayer();
                }
                if (msg.type === "frame") {
                  this.refreshFrames();
                }
              } catch (_) {}
            };
          };
          connect();
        },
        sendControl(controlType, payload) {
          if (!this.ws || this.ws.readyState !== 1) return;
          const msg = { type: "control", controlType, payload };
          this.ws.send(JSON.stringify(msg));
        },
        updateParam(p, evt) {
          const val = parseFloat(evt.target.value);
          p.val = val;
          this.queueLiveParam(p.key, val);
        },
        setSource(key, source) {
          this.paramSources[key] = source;
          this.sendControl("paramSource", { key, source });
        },
        sourceTip(p) {
          const src = this.paramSources[p.key];
          if (src === "Beat") return "Beat/LFO";
          if (src === "MIDI") return "MIDI mapping";
          return "Manual";
        },
        sendPreset(name) {
          const preset = this.motionPresets[name];
          if (!preset) return;
          this.sendControl("liveParam", preset);
          console.log(`Applied motion preset: ${name}`, preset);
        },
        midiTarget(key) {
          return this.lfoTargets.find((t) => t.key === key) || null;
        },
        updateMidiMapping(map) {
          // noop hook for now; v-model already updates
          return map;
        },
        setMorph(on) {
          this.prompts.morphOn = on;
          this.sendControl("prompts", { morphOn: on });
          if (on) {
            this.applyPromptMorphing();
          }
        },
        applyPromptMorphing() {
          if (!this.prompts.morphOn) return;
          const activeSlots = this.morphSlots.filter(s => s.on);
          if (!activeSlots.length) return;
          let morphedPrompt = this.prompts.pos || "";
          activeSlots.forEach(slot => {
            // TODO: Add slider or auto-calculation for blend weight
            // For now using simple concatenation approach
            morphedPrompt += `, ${slot.a} to ${slot.b} blend`;
          });
          this.sendControl("prompt", { positive: morphedPrompt, negative: this.prompts.neg });
        },
        sendPrompts() {
          this.sendControl("prompt", { positive: this.prompts.pos, negative: this.prompts.neg });
          if (this.prompts.morphOn) {
            this.applyPromptMorphing();
          }
        },
        addMacro() {
          if (this.macrosRack.length >= 6) return;
          this.macrosRack.push({ on: true, target: "Vibe (CFG)", shape: "Sine", speed: "1/4 note", depth: 0.5, offset: 0.0, show: false });
        },
        addAudioMapping() {
          this.audioMappings.push({ param: "", freq_min: 60, freq_max: 500, out_min: 0, out_max: 1 });
        },
        removeAudioMapping(index) {
          this.audioMappings.splice(index, 1);
        },
        addLfo() {
          const nextId = this.lfos.length ? Math.max(...this.lfos.map((l) => l.id)) + 1 : 1;
          this.lfos.push({
            id: nextId,
            on: true,
            target: "",
            shape: "Sine",
            bpm: this.lfoBpm || 120,
            depth: 0.2,
            base: null,
            phase: 0,
          });
        },
        removeLfo(index) {
          if (this.lfos.length <= 1) return;
          this.lfos.splice(index, 1);
        },
        queueLiveParam(key, val) {
          const now = this.getNow();
          const last = this.lastParamSent[key] || 0;
          this.liveParamPending[key] = val;
          if (now - last > this.controlDelayMs) {
            this.lastParamSent[key] = now;
            this.sendControl("liveParam", { [key]: val });
            return;
          }
          clearTimeout(this.liveParamTimers[key]);
          this.liveParamTimers[key] = setTimeout(() => {
            const v = this.liveParamPending[key];
            delete this.liveParamPending[key];
            this.lastParamSent[key] = this.getNow();
            this.sendControl("liveParam", { [key]: v });
          }, this.controlDelayMs);
        },
        async refreshFrames() {
          if (typeof fetch !== "function") return;
          try {
            const res = await fetch("/api/frames?limit=10", { cache: "no-store" });
            if (!res.ok) return;
            const json = await res.json();
            if (Array.isArray(json.items)) {
              this.thumbs = json.items.map((item) => {
                if (typeof item === "string") {
                  return { src: item, name: item.split("/").pop(), frame: this.parseFrameNumber(item) };
                }
                const src = item.src || item.url || item.path || "";
                const name = item.name || src.split("/").pop();
                const frame = item.frame != null ? item.frame : this.parseFrameNumber(name || src);
                return { src, name, frame };
              });
            }
          } catch (e) {
            console.warn("frames fetch failed", e);
          }
        },
        parseFrameNumber(name) {
          if (!name) return null;
          const match = String(name).match(/(\d{3,})/);
          return match ? parseInt(match.pop(), 10) : null;
        },
        async runAudioMod() {
          if (!this.audio.track) {
            this.audioStatus = "Set audio file first";
            return;
          }
          const mappings = this.audioMappings
            .filter((m) => m.param && !Number.isNaN(m.freq_min) && !Number.isNaN(m.freq_max))
            .map((m) => ({
              param: m.param,
              freq_min: m.freq_min,
              freq_max: m.freq_max,
              out_min: m.out_min ?? 0,
              out_max: m.out_max ?? 1,
            }));
          if (!mappings.length) {
            this.audioStatus = "Add at least one mapping";
            return;
          }
          try {
            const res = await fetch("/api/audio-map", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                audioPath: this.audio.track,
                fps: this.stats.fps || 24,
                mappings,
                live: true,
              }),
            });
            const json = await res.json();
            if (!res.ok || json.error) {
              this.audioStatus = json.error || "Audio processing failed";
            } else {
              this.audioStatus = json.ok ? "Audio sent to mediator" : "Audio processing finished with errors";
            }
          } catch (err) {
            this.audioStatus = String(err);
          }
        },
        frameLabel(t) {
          if (!t) return "?";
          if (t.frame != null && !isNaN(t.frame)) return t.frame;
          if (t.name) return t.name.replace(/\.[^.]+$/, "");
          return t.src || "?";
        },
        async scanMidi() {
          if (!navigator.requestMIDIAccess) {
            this.midi.supported = false;
            return;
          }
          try {
            const access = await navigator.requestMIDIAccess({ sysex: false });
            const devices = [];
            access.inputs.forEach((input) => {
              devices.push({ id: input.id, name: input.name });
              input.onmidimessage = (msg) => this.handleMidi(input, msg);
            });
            this.midi.devices = devices;
            if (!this.midi.selected && devices.length) this.midi.selected = devices[0].id;
            this.loadMidiMappings();
          } catch (e) {
            this.midiStatus = "MIDI not available";
          }
        },
        loadMidiMappings() {
          const storage = (typeof window !== 'undefined' && window.localStorage) || 
                         (typeof global !== 'undefined' && global.window && global.window.localStorage);
          if (!storage) return;
          try {
            const stored = storage.getItem("defora_midi_mappings");
            if (stored) {
              const mappings = JSON.parse(stored);
              if (Array.isArray(mappings) && mappings.length > 0) {
                this.midi.mappings = mappings;
                console.log("Loaded MIDI mappings from localStorage", mappings);
              }
            }
          } catch (e) {
            console.error("Failed to load MIDI mappings", e);
          }
        },
        saveMidiMappings() {
          const storage = (typeof window !== 'undefined' && window.localStorage) || 
                         (typeof global !== 'undefined' && global.window && global.window.localStorage);
          if (!storage) return false;
          try {
            storage.setItem("defora_midi_mappings", JSON.stringify(this.midi.mappings));
            console.log("Saved MIDI mappings to localStorage", this.midi.mappings);
            return true;
          } catch (e) {
            console.error("Failed to save MIDI mappings", e);
            return false;
          }
        },
        addMidiMapping() {
          this.midi.mappings.push({ control: "New Mapping", cc: 0, key: "" });
          this.saveMidiMappings();
        },
        deleteMidiMapping(index) {
          this.midi.mappings.splice(index, 1);
          this.saveMidiMappings();
        },
        updateMidiMapping(map) {
          this.saveMidiMappings();
          return map;
        },
        // Preset management methods
        async refreshPresets() {
          try {
            const res = await fetch("/api/presets");
            const data = await res.json();
            this.availablePresets = data.presets || [];
          } catch (err) {
            console.error("Failed to load presets", err);
          }
        },
        async loadPreset(name) {
          try {
            const res = await fetch(`/api/presets/${name}`);
            const data = await res.json();
            if (data.preset) {
              // Apply preset to current state
              if (data.preset.liveVibe) this.liveVibe = data.preset.liveVibe;
              if (data.preset.liveCam) this.liveCam = data.preset.liveCam;
              if (data.preset.audio) Object.assign(this.audio, data.preset.audio);
              if (data.preset.cn) Object.assign(this.cn, data.preset.cn);
              if (data.preset.lfos) this.lfos = data.preset.lfos;
              if (data.preset.macrosRack) this.macrosRack = data.preset.macrosRack;
              this.currentPreset = name;
              this.presetStatus = `Loaded preset: ${name}`;
              setTimeout(() => { this.presetStatus = ""; }, 3000);
            }
          } catch (err) {
            console.error("Failed to load preset", err);
            this.presetStatus = `Error loading preset: ${err.message}`;
          }
        },
        async saveCurrentPreset() {
          const name = this.newPresetName || "untitled";
          const preset = {
            liveVibe: this.liveVibe,
            liveCam: this.liveCam,
            audio: { bpm: this.audio.bpm, track: this.audio.track },
            cn: { slots: this.cn.slots, active: this.cn.active },
            lfos: this.lfos,
            macrosRack: this.macrosRack,
            paramSources: this.paramSources,
          };
          try {
            const res = await fetch(`/api/presets/${name}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(preset),
            });
            const data = await res.json();
            if (data.ok) {
              this.currentPreset = name;
              this.presetStatus = `Saved preset: ${name}`;
              this.newPresetName = "";
              await this.refreshPresets();
              setTimeout(() => { this.presetStatus = ""; }, 3000);
            }
          } catch (err) {
            console.error("Failed to save preset", err);
            this.presetStatus = `Error saving preset: ${err.message}`;
          }
        },
        async deletePreset(name) {
          if (!confirm(`Delete preset "${name}"?`)) return;
          try {
            await fetch(`/api/presets/${name}`, { method: "DELETE" });
            this.currentPreset = null;
            this.presetStatus = `Deleted preset: ${name}`;
            await this.refreshPresets();
            setTimeout(() => { this.presetStatus = ""; }, 3000);
          } catch (err) {
            console.error("Failed to delete preset", err);
            this.presetStatus = `Error deleting preset: ${err.message}`;
          }
        },
        // Audio file upload methods
        handleAudioUpload(evt) {
          const file = evt.target.files[0];
          if (!file) return;
          this.audio.uploadedFile = file.name;
          this.audio.track = file.name;
          // In a real implementation, you would upload the file to the server here
          // For now, we just store the filename
          console.log("Audio file selected:", file.name);
        },
        clearAudioFile() {
          this.audio.uploadedFile = null;
          this.audio.track = "";
          if (this.$refs.audioFileInput) {
            this.$refs.audioFileInput.value = "";
          }
        },
        // ControlNet methods
        async loadControlNetModels() {
          try {
            const res = await fetch("/api/controlnet/models");
            const data = await res.json();
            this.cn.availableModels = data.models || [];
          } catch (err) {
            console.error("Failed to load ControlNet models", err);
          }
        },
        updateControlNet(slot) {
          // Send ControlNet parameters to mediator
          const payload = {
            controlnet_slot: slot.id,
            controlnet_model: slot.model,
            controlnet_weight: slot.weight,
            controlnet_start: slot.start,
            controlnet_end: slot.end,
            controlnet_enabled: slot.enabled,
          };
          this.sendControl("controlNet", payload);
          console.log("Updated ControlNet slot:", slot.id, payload);
        },
        uploadControlNetImage(slot) {
          // Placeholder for image upload functionality
          // In a real implementation, this would open a file picker and upload the image
          console.log("Upload image for slot:", slot.id);
          alert("Image upload functionality not yet implemented. Use SD-Forge UI for now.");
        },
        handleMidi(input, msg) {
          const [status, cc, value] = msg.data;
          const isCC = (status & 0xf0) === 0xb0;
          if (!isCC) return;
          const mapping = this.midi.mappings.find((m) => m.cc === cc);
          const norm = value / 127;
          if (mapping && mapping.key) {
            const target = this.midiTarget(mapping.key);
            if (target) {
              const scaled = target.min + norm * (target.max - target.min);
              this.sendControl("liveParam", { [target.key]: scaled });
            } else {
              this.sendControl("liveParam", { [mapping.key]: norm });
            }
          }
        },
        xyPadMouseDown(evt) {
          this.xyPad.dragging = true;
          this.updateXyPad(evt);
          evt.preventDefault();
        },
        xyPadMouseMove(evt) {
          if (!this.xyPad.dragging) return;
          this.updateXyPad(evt);
          evt.preventDefault();
        },
        xyPadMouseUp() {
          this.xyPad.dragging = false;
        },
        updateXyPad(evt) {
          const pad = evt.currentTarget;
          const rect = pad.getBoundingClientRect();
          let clientX, clientY;
          if (evt.touches && evt.touches.length > 0) {
            clientX = evt.touches[0].clientX;
            clientY = evt.touches[0].clientY;
          } else {
            clientX = evt.clientX;
            clientY = evt.clientY;
          }
          const x = Math.max(0, Math.min(this.xyPad.padSize, clientX - rect.left));
          const y = Math.max(0, Math.min(this.xyPad.padSize, clientY - rect.top));
          this.xyPad.x = x;
          this.xyPad.y = y;
          // Normalize pad coordinates to -1..1, then scale to translation range -10..10
          const normX = (x / this.xyPad.padSize) * 2 - 1;
          const normY = 1 - (y / this.xyPad.padSize) * 2;
          const TRANSLATION_RANGE = 10; // Max translation distance for camera movement
          const translation_x = normX * TRANSLATION_RANGE;
          const translation_y = normY * TRANSLATION_RANGE;
          this.queueLiveParam("translation_x", translation_x);
          this.queueLiveParam("translation_y", translation_y);
        },
      },
    }).mount("#app");
  </script>
</body>
</html>
