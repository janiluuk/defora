<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Defora Web</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/vue@3.4.27/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --bg: #06080f;
      --panel: #0f1422;
      --panel-2: #11182d;
      --border: #1f2a44;
      --glow1: #ff53d9;
      --glow2: #2de2ff;
      --text: #e8edf7;
      --muted: #9bb1d0;
      --success: #5af2a9;
      --danger: #ff4d6d;
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", Arial, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(255, 83, 217, 0.12), transparent 25%),
                  radial-gradient(circle at 80% 0%, rgba(45, 226, 255, 0.12), transparent 25%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 12px 16px;
      background: rgba(13, 18, 34, 0.8);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(6px);
      display: grid;
      grid-template-columns: 1.4fr 1fr 1fr;
      gap: 10px;
      align-items: center;
    }
    .brand { font-weight: 700; letter-spacing: 0.5px; font-size: 18px; }
    .tabs { display: flex; gap: 6px; flex-wrap: wrap; }
    .tab { padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border); background: #0f172a; color: var(--muted); cursor: pointer; }
    .tab.active { border-color: var(--glow2); color: var(--text); box-shadow: 0 6px 20px rgba(45,226,255,0.12); }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 999px; border: 1px solid var(--border); background: #11182d; color: var(--muted); font-size: 12px; }
    .pill .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); box-shadow: 0 0 8px var(--success); }
    .pill.danger .dot { background: var(--danger); box-shadow: 0 0 8px var(--danger); }
    .btn { background: linear-gradient(90deg, var(--glow1), var(--glow2)); color: #0a0c12; border: none; border-radius: 999px; padding: 8px 12px; font-weight: 700; cursor: pointer; }
    .btn.ghost { background: #0f172a; color: var(--text); border: 1px solid var(--border); }
    .layout { flex: 1; display: grid; grid-template-columns: 1.8fr 1fr; gap: 10px; padding: 10px; }
    .preview { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); padding: 10px; display: grid; gap: 10px; }
    .video-wrap { position: relative; border-radius: var(--radius); overflow: hidden; border: 1px solid var(--border); background: #000; }
    video { width: 100%; display: block; background: #000; }
    .overlay { position: absolute; left: 0; right: 0; bottom: 0; display: flex; justify-content: space-between; padding: 8px 10px; background: linear-gradient(180deg, transparent, rgba(0,0,0,0.7)); font-size: 12px; }
    .timeline { background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 8px; }
    .thumbs { display: flex; gap: 8px; overflow-x: auto; margin-bottom: 6px; padding-bottom: 4px; }
    .thumb-card { position: relative; border-radius: 10px; overflow: hidden; border: 1px solid var(--border); background: #0b0f1c; box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
    .thumb { width: 92px; height: 54px; display: block; background: #11182a; object-fit: cover; }
    .thumb-label { position: absolute; left: 0; right: 0; bottom: 0; padding: 3px 6px; font-size: 11px; color: var(--text); background: linear-gradient(180deg, transparent, rgba(0,0,0,0.7)); }
    .wave { height: 40px; border-radius: 8px; background: linear-gradient(90deg, rgba(255,83,217,0.2), rgba(45,226,255,0.2)); border: 1px solid var(--border); }
    .wave { position: relative; display: flex; align-items: flex-end; overflow: hidden; }
    .wave-bar { width: 1.5%; background: rgba(45,226,255,0.65); margin-right: 1px; min-height: 4px; border-radius: 4px 4px 0 0; }
    .beat-marker { position: absolute; top: 0; bottom: 0; width: 2px; background: rgba(255,83,217,0.45); }
    .band-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; }
    .band-card { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #0e1322; }
    .band-bar { height: 6px; background: linear-gradient(90deg, var(--glow1), var(--glow2)); border-radius: 999px; position: relative; margin-top: 6px; }
    .band-window { position: absolute; top: -4px; bottom: -4px; background: rgba(45,226,255,0.2); border: 1px solid var(--glow2); border-radius: 8px; }
    .rack { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .rack h3 { margin: 0 0 8px 0; }
    .slider-row { display: grid; grid-template-columns: 1.1fr 1fr; gap: 8px; align-items: center; margin: 8px 0; font-size: 13px; color: var(--muted); }
    .slider-row input[type=range] { width: 100%; accent-color: var(--glow2); }
    .source { display: inline-flex; gap: 6px; font-size: 12px; color: var(--muted); align-items: center; }
    .chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { padding: 8px 12px; border-radius: 999px; border: 1px solid var(--border); background: #11182a; color: var(--text); cursor: pointer; }
    .chip.active { border-color: var(--glow2); color: var(--glow2); }
    .context { grid-column: 1 / span 2; background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; }
    .context h4 { margin: 0 0 6px 0; }
    .table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text); }
    .table th, .table td { padding: 6px 8px; border-bottom: 1px solid var(--border); text-align: left; }
    .xy-pad { width: 140px; height: 140px; border-radius: 12px; border: 1px solid var(--border); background: #0f172a; position: relative; }
    .xy-dot { position: absolute; width: 12px; height: 12px; border-radius: 50%; background: var(--glow2); box-shadow: 0 0 10px var(--glow2); }
    .lfo-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; }
    .lfo-card { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: #0e1322; box-shadow: 0 8px 18px rgba(0,0,0,0.28); }
    .lfo-card h4 { margin: 0 0 6px 0; display: flex; align-items: center; justify-content: space-between; font-size: 14px; }
    .lfo-card .meta { font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    .lfo-card select, .lfo-card input[type=number] { width: 100%; padding: 6px; border-radius: 8px; border: 1px solid var(--border); background: #0f172a; color: var(--text); }
    .lfo-card .switch { display: inline-flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px; color: var(--muted); }
    .audio-map-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: 10px; }
    .audio-map-card { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #0f172a; }
    @media (max-width: 1100px) {
      .layout { grid-template-columns: 1fr; }
      .context { grid-column: 1; }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="brand">Defora ¬∑ Session: {{ session }}</div>
      <div class="tabs">
        <button class="tab" v-for="tab in tabs" :key="tab.id" :class="{active: currentTab===tab.id}" @click="switchTab(tab.id)">
          {{ tab.label }}
        </button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
        <button class="btn" @click="sendControl('transport',{action:'toggle'})">‚èØ</button>
        <button class="btn ghost" @click="sendControl('transport',{action:'stop'})">‚èπ</button>
        <button class="btn ghost" @click="sendControl('transport',{action:'record'})">‚óè Rec</button>
        <div class="pill"><span>FPS</span><strong>{{ stats.fps }}</strong></div>
        <div class="pill"><span>Lat</span><strong>{{ stats.lat }}ms</strong></div>
      </div>
    </header>

    <div class="layout">
      <!-- Left: video + mini timeline -->
      <div class="preview">
        <div class="video-wrap">
          <video id="player" controls autoplay muted playsinline></video>
          <div class="overlay">
            <div>Time {{ timecode }}</div>
            <div>Seed {{ hud.seed }}</div>
          </div>
        </div>
        <div class="timeline">
          <div class="thumbs">
            <template v-if="thumbs.length">
              <div class="thumb-card" v-for="t in thumbs" :key="t.src">
                <img class="thumb" :src="t.src" loading="lazy" :alt="'frame '+frameLabel(t)" />
                <div class="thumb-label">#{{ frameLabel(t) }}</div>
              </div>
            </template>
            <template v-else>
              <div class="thumb-card" v-for="n in 6" :key="'ph'+n">
                <div class="thumb"></div>
                <div class="thumb-label">waiting‚Ä¶</div>
              </div>
            </template>
          </div>
          <div class="wave">
            <template v-if="waveformPeaks.length">
              <div class="wave-bar" v-for="(p,idx) in waveformPeaks" :key="'w'+idx" :style="{height:(Math.abs(p)*100)+'%'}"></div>
            </template>
            <template v-else>
              <div style="padding:8px; color:var(--muted); font-size:12px;">Load audio analysis to see waveform/beat grid</div>
            </template>
            <div class="beat-marker" v-for="(b,idx) in beatGrid" :key="'b'+idx" :style="{left: beatPos(b)+'%'}"></div>
          </div>
        </div>
      </div>

      <!-- Right: control rack per tab -->
      <div>
        <div v-if="currentTab==='LIVE'">
          <div class="rack">
            <h3>Vibe & Style</h3>
            <div class="slider-row" v-for="p in liveVibe" :key="p.key">
              <div>{{ p.label }}</div>
              <div>
                <input type="range" :min="p.min" :max="p.max" :step="p.step" :value="p.val" @input="updateParam(p,$event)">
                <div class="source">
                  <span :title="sourceTip(p)">Source: </span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Manual'}" @click="setSource(p.key,'Manual')">Manual</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Beat'}" @click="setSource(p.key,'Beat')">üåä Beat</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='MIDI'}" @click="setSource(p.key,'MIDI')">üéõ MIDI</span>
                </div>
              </div>
            </div>
          </div>
          <div class="rack">
            <h3>Camera</h3>
            <div class="slider-row" v-for="p in liveCam" :key="p.key">
              <div>{{ p.label }}</div>
              <div>
                <input type="range" :min="p.min" :max="p.max" :step="p.step" :value="p.val" @input="updateParam(p,$event)">
                <div class="source" v-if="p.sourceable">
                  <span class="chip" :class="{active: paramSources[p.key]==='Manual'}" @click="setSource(p.key,'Manual')">Manual</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Beat'}" @click="setSource(p.key,'Beat')">üåä Beat</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='MIDI'}" @click="setSource(p.key,'MIDI')">üéõ MIDI</span>
                </div>
              </div>
            </div>
            <div class="chips">
              <span class="chip" v-for="p in motionPresets" :key="p" @click="sendPreset(p)">{{ p }}</span>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='PROMPTS'">
          <div class="rack">
            <h3>Positive prompts (A/B)</h3>
            <textarea class="select" v-model="prompts.posA" rows="3" placeholder="Positive prompt A"></textarea>
            <textarea class="select" v-model="prompts.posB" rows="3" placeholder="Positive prompt B" style="margin-top:6px;"></textarea>
          </div>
          <div class="rack">
            <h3>Negative prompt</h3>
            <textarea class="select" v-model="prompts.neg" rows="2" placeholder="negative prompt"></textarea>
          </div>
          <div class="rack">
            <h3>Prompt crossfade</h3>
            <div class="chips">
              <span class="chip" :class="{active: prompts.morphOn}" @click="setMorph(true)">‚òë Enable</span>
              <span class="chip" :class="{active: !prompts.morphOn}" @click="setMorph(false)">‚òê Disable</span>
            </div>
            <div style="margin-top:10px;">
              <div class="slider-row">
                <div>Crossfade A‚ÜíB</div>
                <input type="range" min="0" max="1" step="0.01" v-model.number="prompts.mix" @input="sendPromptsDebounced">
              </div>
              <div style="font-size:12px; color:var(--muted);">A weight: {{ ((1-prompts.mix)*100).toFixed(0) }}% ¬∑ B weight: {{ (prompts.mix*100).toFixed(0) }}%</div>
              <button class="btn ghost" style="margin-top:6px;" @click="sendPrompts">Send prompts</button>
            </div>
            <div style="margin-top:10px;">
              <div class="slider-row">
                <div>Schedule slots</div>
                <span style="font-size:12px; color:var(--muted);">Click + to add morph slots over time (seconds ‚Üí mix)</span>
              </div>
              <div class="audio-map-grid" style="align-items:center;">
                <div class="audio-map-card" v-for="(slot,idx) in promptSchedule" :key="'ps'+idx">
                  <div class="meta">Time (s)</div>
                  <input type="number" min="0" step="0.5" v-model.number="slot.t" @input="updatePromptGraph">
                  <div class="meta">Mix (0-1)</div>
                  <input type="number" min="0" max="1" step="0.01" v-model.number="slot.mix" @input="updatePromptGraph">
                  <button class="btn ghost" style="margin-top:6px;" @click="removePromptSlot(idx)">Delete</button>
                </div>
              </div>
              <span class="chip" @click="addPromptSlot" v-if="promptSchedule.length<12">+ Add slot</span>
              <div class="wave" style="margin-top:10px; height:50px; position:relative; overflow:hidden;">
                <svg :width="'100%'" height="50" viewBox="0 0 100 50" preserveAspectRatio="none">
                  <polyline :points="promptPolyline" fill="none" stroke="var(--glow2)" stroke-width="2" />
                </svg>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='MOTION'">
          <div class="rack">
            <h3>Camera pad</h3>
            <div class="xy-pad">
              <div class="xy-dot" :style="{left:'60px', top:'60px'}"></div>
            </div>
          </div>
          <div class="rack">
            <h3>Zoom & Tilt</h3>
            <div class="slider-row">
              <div>Zoom</div>
              <input type="range" min="-10" max="10" step="0.05" :value="camVal('translation_z')" @input="updateCam('translation_z',$event)">
            </div>
            <div class="slider-row">
              <div>Tilt</div>
              <input type="range" min="-180" max="180" step="0.5" :value="camVal('rotation_z')" @input="updateCam('rotation_z',$event)">
            </div>
          </div>
          <div class="rack">
            <h3>Motion style</h3>
            <div class="chips">
              <span class="chip" v-for="m in motionStyles" :key="m" @click="sendMotionPreset(m)">{{ m }}</span>
            </div>
            <div class="slider-row" style="margin-top:6px;">
              <div>Intensity</div>
              <input type="range" min="0.2" max="2" step="0.1" v-model.number="motionIntensity">
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='AUDIO'">
          <div class="rack">
            <h3>Track & tempo</h3>
            <div class="slider-row"><div>Track</div><input class="select" v-model="audio.track" placeholder="/path/to/track.wav"></div>
            <div class="slider-row"><div>BPM</div><input class="select" type="number" v-model.number="audio.bpm"></div>
            <div class="chips" style="margin-top:6px;">
              <span class="chip" @click="loadAudioAnalysis">Load analysis</span>
              <span class="chip" @click="tapTempo">Tap tempo</span>
              <span class="chip" @click="audio.bpm = Math.round(audio.bpm || 120)">Round BPM</span>
            </div>
          </div>
          <div class="rack">
            <h3>Audio band mappings</h3>
            <div class="band-grid">
              <div class="band-card" v-for="(b,idx) in bands" :key="'band'+idx">
                <h4 style="margin:0 0 6px 0; display:flex; justify-content:space-between; align-items:center;">
                  {{ b.label }} <span class="pill" style="cursor:pointer;" @click="previewBand(b)">Preview</span>
                </h4>
                <div class="meta">Target</div>
                <select v-model="b.param">
                  <option v-for="t in lfoTargets" :key="'bt'+t.key" :value="t.key">{{ t.label }}</option>
                </select>
                <div class="meta">Freq range (Hz)</div>
                <div style="display:flex; gap:6px;">
                  <input type="number" min="0" max="20000" step="10" v-model.number="b.freq_min" style="flex:1;">
                  <input type="number" min="0" max="20000" step="10" v-model.number="b.freq_max" style="flex:1;">
                </div>
                <div class="meta">Intensity</div>
                <input type="range" min="0" max="3" step="0.05" v-model.number="b.intensity">
                <div class="band-bar">
                  <div class="band-window" :style="{left: (b.freq_min/20000*100)+'%', right: (100 - (b.freq_max/20000*100))+'%', opacity: 0.4 + b.intensity/3}"></div>
                </div>
              </div>
            </div>
            <div class="audio-map-grid">
              <div class="audio-map-card" v-for="(m, idx) in audioMappings" :key="'map'+idx">
                <div class="meta">Target</div>
                <select v-model="m.param">
                  <option value="">(none)</option>
                  <option v-for="t in lfoTargets" :key="'amap'+t.key" :value="t.key">{{ t.label }}</option>
                </select>
                <div class="slider-row" style="margin-top:6px;">
                  <div>Freq min</div><input type="number" min="0" step="10" v-model.number="m.freq_min">
                </div>
                <div class="slider-row">
                  <div>Freq max</div><input type="number" min="0" step="10" v-model.number="m.freq_max">
                </div>
                <div class="slider-row">
                  <div>Out min</div><input type="number" step="0.01" v-model.number="m.out_min">
                </div>
                <div class="slider-row">
                  <div>Out max</div><input type="number" step="0.01" v-model.number="m.out_max">
                </div>
              </div>
            </div>
            <div class="chips" style="margin-top:8px;">
              <span class="chip" @click="addAudioMapping" v-if="audioMappings.length<6">+ Add mapping</span>
              <span class="chip" @click="runAudioMod">Process audio ‚Üí mediator</span>
              <span class="chip" style="color:var(--muted);">Status: {{ audioStatus }}</span>
            </div>
          </div>
          <div class="rack">
            <h3>Macro lanes (beat-driven)</h3>
            <div class="lfo-grid">
              <div class="lfo-card" v-for="(m,idx) in macrosRack" :key="'macro'+idx">
                <h4>Lane {{ idx+1 }} <span class="pill" :class="{danger:!m.on}" style="margin-left:6px; cursor:pointer;" @click="m.on=!m.on">{{ m.on ? 'ON' : 'OFF' }}</span></h4>
                <div class="meta">Target</div>
                <select v-model="m.target">
                  <option v-for="t in lfoTargets" :key="'mt'+t.key" :value="t.key">{{ t.label }}</option>
                </select>
                <div class="meta">Shape</div>
                <select v-model="m.shape">
                  <option v-for="s in lfoShapes" :key="'ms'+s">{{ s }}</option>
                </select>
                <div class="meta">Speed</div>
                <select v-model="m.speed">
                  <option>1/8 note</option>
                  <option>1/4 note</option>
                  <option>1/2 note</option>
                  <option>1 bar</option>
                </select>
                <div class="meta">Depth</div>
                <input type="number" min="0" max="1" step="0.05" v-model.number="m.depth">
                <div class="meta">Start beat / End beat</div>
                <div style="display:flex; gap:6px;">
                  <input type="number" v-model.number="m.startBeat" min="0" style="flex:1;">
                  <input type="number" v-model.number="m.endBeat" min="0" style="flex:1;">
                </div>
              </div>
            </div>
          </div>
          <div class="rack">
            <h3>LFOs</h3>
            <div class="lfo-grid">
              <div class="lfo-card" v-for="(l,idx) in lfos" :key="'lfo'+idx">
                <h4>LFO {{ l.id }} <span class="pill" :class="{danger:!l.on}" style="margin-left:6px; cursor:pointer;" @click="l.on=!l.on">{{ l.on ? 'ON' : 'OFF' }}</span></h4>
                <div class="meta">Target</div>
                <select v-model="l.target" @change="initLfoBase(l)">
                  <option value="">(none)</option>
                  <option v-for="t in lfoTargets" :key="'lt'+t.key" :value="t.key">{{ t.label }}</option>
                </select>
                <div class="meta">Shape / Depth / Base</div>
                <select v-model="l.shape">
                  <option v-for="s in lfoShapes" :key="'ls'+s">{{ s }}</option>
                </select>
                <input type="number" min="0" max="1" step="0.05" v-model.number="l.depth">
                <input type="number" step="0.1" v-model.number="l.base">
                <div class="meta">BPM (or rate)</div>
                <input type="number" min="1" step="1" v-model.number="l.bpm">
                <div class="meta"><label><input type="checkbox" v-model="l.sync"> Sync to BPM</label></div>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='CONTROLNET'">
          <div class="rack">
            <h3>ControlNet slots</h3>
            <div class="chips">
              <span class="chip" v-for="cnSlot in controlnetSlots" :key="cnSlot.id" :class="{active: controlnetActive===cnSlot.id}" @click="controlnetActive=cnSlot.id">{{ cnSlot.label }}</span>
            </div>
          </div>
          <div class="rack">
            <h3>{{ controlnetActive }}</h3>
            <div class="audio-map-grid" style="margin-top:8px;" v-if="activeSlot">
              <div class="audio-map-card">
                <div class="meta">Weight</div>
                <input type="range" min="0" max="2" step="0.05" v-model.number="activeSlot.weight" @input="sendControlNet(activeSlot)">
                <div class="chips" style="margin-top:6px;">
                  <span class="chip" :class="{active:activeSlot.enabled}" @click="activeSlot.enabled=!activeSlot.enabled; sendControlNet(activeSlot)">{{ activeSlot.enabled ? 'Enabled' : 'Disabled' }}</span>
                  <span class="chip" :class="{active:activeSlot.bypass}" @click="activeSlot.bypass=!activeSlot.bypass; sendControlNet(activeSlot)">{{ activeSlot.bypass ? 'Bypass' : 'Live' }}</span>
                </div>
                <div style="font-size:12px; color:var(--muted); margin-top:6px;">Sends weight/enabled/bypass to mediator (controlnet payload).</div>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='SETTINGS'">
          <div class="rack">
            <h3>Engine</h3>
            <div class="slider-row"><div>Resolution</div><select class="select"><option>1024x576</option><option>1280x720</option></select></div>
            <div class="slider-row"><div>FPS</div><select class="select"><option>24</option><option selected>30</option><option>60</option></select></div>
            <div class="slider-row"><div>Steps</div><select class="select"><option>24</option><option>30</option><option>40</option></select></div>
            <div class="chips">
              <span class="chip">Seed: 42490527</span>
              <span class="chip">Sampler: DPM++ 2M Karras</span>
            </div>
          </div>
          <div class="rack">
            <h3>Controllers (WebMIDI)</h3>
            <div v-if="!midi.supported" style="color:var(--muted);">WebMIDI not supported or not enabled.</div>
            <div v-else>
              <div class="chips" style="margin-bottom:6px;">
                <span class="chip" v-for="d in midi.devices" :key="d.id" :class="{active: midi.selected===d.id}" @click="midi.selected=d.id">{{ d.name }}</span>
                <span class="chip" @click="scanMidi()">Rescan</span>
              </div>
              <div class="chips"><span class="chip">Learn mode</span><span class="chip">Status: {{ midiStatus }}</span></div>
              <table class="table">
                <thead><tr><th>Source</th><th>Target</th><th>Mode</th><th>Curve</th></tr></thead>
                <tbody>
                  <tr v-for="m in midi.mappings" :key="m.control">
                    <td>{{ m.control }}</td><td>{{ m.param }}</td><td>Absolute</td><td>Linear</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Bottom context panel -->
      <div class="context">
        <div v-if="currentTab==='LIVE'">
          <h4>Beat & MIDI status</h4>
          <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="min-width:240px;">
              <strong>Beat macros ({{ macrosRack.length }})</strong>
              <div v-for="m in macrosRack" :key="m.target" style="font-size:12px; color:var(--muted);">
                ‚Ä¢ {{ m.target }} ‚Äì {{ m.shape }} @ {{ m.speed }} ‚Äì Depth {{ (m.depth*100).toFixed(0) }}%
              </div>
            </div>
            <div style="min-width:240px;">
              <strong>MIDI mappings</strong>
              <div style="font-size:12px; color:var(--muted);">
                ‚Ä¢ LaunchControl CC21 ‚Üí Vibe<br/>
                ‚Ä¢ LaunchControl CC22 ‚Üí Strength<br/>
                ‚Ä¢ LaunchControl CC23 ‚Üí Zoom
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='PROMPTS'">
          <h4>Morph slots</h4>
          <table class="table">
            <thead><tr><th>ID</th><th>On</th><th>Name</th><th>A prompt</th><th>B prompt</th><th>Range</th></tr></thead>
            <tbody>
              <tr v-for="slot in morphSlots" :key="slot.id">
                <td>{{ slot.id }}</td>
                <td>{{ slot.on ? '‚óè' : '‚óã' }}</td>
                <td>{{ slot.name }}</td>
                <td>{{ slot.a }}</td>
                <td>{{ slot.b }}</td>
                <td>{{ slot.range }}</td>
              </tr>
            </tbody>
          </table>
          <div class="chips"><span class="chip">+ Add morph</span><span class="chip">Copy from preset</span></div>
        </div>

        <div v-else-if="currentTab==='MOTION'">
          <h4>Camera curves</h4>
          <div class="wave" style="height:100px; background:#11182a; margin-bottom:8px;"></div>
          <div style="font-size:12px; color:var(--muted);">Pan X/Y and Zoom curves over beats. Tools: Apply Sine/Saw, Smooth, Snap to Beats.</div>
        </div>

        <div v-else-if="currentTab==='AUDIO'">
          <h4>Active macro curve</h4>
          <div class="wave" style="height:120px; background:#11182a; margin-bottom:8px;"></div>
          <div class="chips">
            <span class="chip">‚ó† Sine</span><span class="chip">‚ñ≥ Triangle</span><span class="chip">/ Saw</span><span class="chip">‚ß† Square</span><span class="chip">~ Noise</span><span class="chip">‚ô´ From audio peaks</span>
          </div>
        </div>

        <div v-else-if="currentTab==='CONTROLNET'">
          <h4>Drive parameters</h4>
          <div class="chips">
            <span class="chip">Vibe / CFG</span><span class="chip">Camera pan</span><span class="chip">Zoom pulses</span><span class="chip">Noise / Glitch</span>
          </div>
        </div>

        <div v-else-if="currentTab==='SETTINGS'">
          <h4>MIDI mappings</h4>
          <table class="table">
            <thead><tr><th>Source</th><th>Target</th><th>Mode</th><th>Curve</th></tr></thead>
            <tbody>
              <tr v-for="m in midi.mappings" :key="m.control+'ctx'">
                <td>{{ m.control || ('CC '+m.cc) }}</td>
                <td>
                  <select class="select" v-model="m.key" @change="updateMidiMapping(m)">
                    <option value="">(none)</option>
                    <option v-for="t in lfoTargets" :key="'map'+t.key" :value="t.key">{{ t.label }}</option>
                  </select>
                </td>
                <td>Absolute</td>
                <td>Linear</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          session: "clown_set_01",
          tabs: [
            { id: "LIVE", label: "LIVE" },
            { id: "PROMPTS", label: "PROMPTS" },
            { id: "MOTION", label: "MOTION" },
            { id: "AUDIO", label: "AUDIO/BEATS" },
            { id: "CONTROLNET", label: "CN" },
            { id: "SETTINGS", label: "SETTINGS" },
          ],
          currentTab: "LIVE",
          stats: { fps: 27, lat: 120 },
          hud: { seed: 42490527 },
          timecode: "00:00.00",
          waveformPeaks: [],
          beatGrid: [],
          lastLfoTick: null,
          modTimeSec: 0,
          lastTapTime: null,
          liveVibe: [
            { key: "cfg", label: "Vibe (CFG)", val: 6.0, min: 0, max: 30, step: 0.5 },
            { key: "strength", label: "Strength", val: 0.65, min: 0, max: 1.5, step: 0.02 },
            { key: "noise_multiplier", label: "Noise/Glitch", val: 1.05, min: 0, max: 3, step: 0.05 },
            { key: "cadence", label: "Cadence", val: 2.0, min: 0, max: 16, step: 0.5 },
          ],
          liveCam: [
            { key: "translation_z", label: "Zoom", val: 0.0, min: -10, max: 10, step: 0.05, sourceable: true },
            { key: "translation_x", label: "Pan X", val: 0.0, min: -10, max: 10, step: 0.05, sourceable: true },
            { key: "translation_y", label: "Pan Y", val: 0.0, min: -10, max: 10, step: 0.05, sourceable: true },
            { key: "rotation_z", label: "Tilt / Rotate", val: 0.0, min: -180, max: 180, step: 0.5, sourceable: true },
            { key: "fov", label: "FOV", val: 70.0, min: 1, max: 180, step: 1.0, sourceable: false },
          ],
          paramSources: {
            cfg: "Manual",
            strength: "Manual",
            noise_multiplier: "Manual",
            cadence: "Manual",
            translation_z: "Manual",
            translation_x: "Manual",
            translation_y: "Manual",
            rotation_z: "Manual",
            fov: "Manual",
          },
          prompts: { posA: "", posB: "", neg: "", morphOn: true, mix: 0.5 },
          promptSchedule: [{ t: 0, mix: 0.0 }, { t: 8, mix: 0.5 }, { t: 16, mix: 1.0 }],
          promptPolyline: "",
          controlnetSlots: [
            { id: "CN1", label: "CN1", weight: 0.4, enabled: true, bypass: false },
            { id: "CN2", label: "CN2", weight: 0.4, enabled: true, bypass: false },
            { id: "CN3", label: "CN3", weight: 0.4, enabled: true, bypass: false },
          ],
          controlnetActive: "CN1",
          morphSlots: [
            { id: 1, on: true, name: "clean ‚Üí mad", a: "clean evil", b: "mad clown", range: "0.40‚Äì1.00" },
            { id: 2, on: true, name: "box ‚Üí tunnel", a: "small box", b: "neon tunnel", range: "0.00‚Äì0.60" },
            { id: 3, on: false, name: "style fade", a: "photographic", b: "anime render", range: "0.20‚Äì0.80" },
          ],
          motionPresets: ["Static", "Orbit", "Tunnel", "Handheld", "Chaos"],
          motionStyles: ["Calm", "Travel", "Spin", "Handheld", "Chaos"],
          motionIntensity: 1.0,
          audio: { track: "", bpm: 114.8 },
          audioStatus: "Idle",
          audioMappings: [
            { param: "strength", freq_min: 20, freq_max: 300, out_min: 0, out_max: 1.5 },
            { param: "cfg", freq_min: 300, freq_max: 1200, out_min: 0, out_max: 30 },
            { param: "translation_z", freq_min: 1200, freq_max: 3000, out_min: -5, out_max: 5 },
          ],
          bands: [
            { label: "Sub", param: "translation_x", freq_min: 20, freq_max: 80, intensity: 0.5 },
            { label: "Low", param: "translation_y", freq_min: 80, freq_max: 250, intensity: 0.8 },
            { label: "Mid", param: "translation_z", freq_min: 250, freq_max: 1200, intensity: 1.0 },
            { label: "High", param: "rotation_z", freq_min: 1200, freq_max: 5000, intensity: 0.6 },
          ],
          lfoBpm: 120,
          lfoTargets: [
            { key: "cfg", label: "Vibe (CFG)", min: 0, max: 30, default: 6 },
            { key: "strength", label: "Strength", min: 0, max: 1.5, default: 0.7 },
            { key: "noise_multiplier", label: "Noise/Glitch", min: 0, max: 3, default: 1.0 },
            { key: "translation_z", label: "Zoom", min: -10, max: 10, default: 0 },
            { key: "translation_x", label: "Pan X", min: -10, max: 10, default: 0 },
            { key: "translation_y", label: "Pan Y", min: -10, max: 10, default: 0 },
            { key: "rotation_y", label: "Rotate Y", min: -180, max: 180, default: 0 },
            { key: "rotation_z", label: "Tilt", min: -180, max: 180, default: 0 },
            { key: "fov", label: "FOV", min: 1, max: 180, default: 70 },
          ],
          lfoShapes: ["Sine", "Triangle", "Saw", "Square"],
          lfos: Array.from({ length: 6 }).map((_, idx) => ({
            id: idx + 1,
            on: idx === 0,
            target: idx === 0 ? "cfg" : "",
            shape: "Sine",
            bpm: 120,
            depth: 0.1,
            base: null,
            phase: 0,
            sync: true,
          })),
          macrosRack: [
            { on: true, target: "cfg", shape: "Sine", speed: "1/4 note", depth: 0.7, base: null, phase: 0, startBeat: 0, endBeat: 64 },
            { on: true, target: "translation_z", shape: "Saw", speed: "1 bar", depth: 0.6, base: null, phase: 0, startBeat: 0, endBeat: 64 },
            { on: false, target: "noise_multiplier", shape: "Triangle", speed: "1/8 note", depth: 0.3, base: null, phase: 0, startBeat: 0, endBeat: 64 },
          ],
          midi: {
            supported: !!navigator.requestMIDIAccess,
            devices: [],
            selected: null,
            mappings: [
              { control: "LaunchControl CC21", cc: 21, key: "cfg" },
              { control: "LaunchControl CC22", cc: 22, key: "strength" },
              { control: "LaunchControl CC23", cc: 23, key: "noise_multiplier" },
            ],
          },
          midiStatus: "Ready",
          ws: null,
          wsStatus: "disconnected",
          streamSrc: "/hls/live/deforum.m3u8",
          thumbs: [],
          framesTimer: null,
          playerEl: null,
          timeHandler: null,
          hls: null,
          liveParamTimers: {},
          liveParamPending: {},
          lastParamSent: {},
          controlDelayMs: 75,
          errorHandler: null,
          playbackTimer: null,
          lfoTimer: null,
          lastLfoTick: null,
        };
      },
      computed: {
        activeSlot() {
          return this.controlnetSlots.find((s) => s.id === this.controlnetActive) || this.controlnetSlots[0];
        },
      },
      mounted() {
        this.attachPlayer();
        this.setupWS();
        this.scanMidi();
        this.loadMediatorState();
        this.refreshFrames();
        if (typeof fetch === "function") {
          this.framesTimer = setInterval(() => this.refreshFrames(), 5000);
        }
        this.playbackTimer = setInterval(() => this.ensureLivePlayback(), 4000);
        this.lfoTimer = setInterval(() => this.runLfos(), 120);
      },
      beforeUnmount() {
        if (this.framesTimer) clearInterval(this.framesTimer);
        if (this.playbackTimer) clearInterval(this.playbackTimer);
        if (this.lfoTimer) clearInterval(this.lfoTimer);
        if (this.playerEl && this.timeHandler) {
          this.playerEl.removeEventListener("timeupdate", this.timeHandler);
        }
        if (this.playerEl && this.errorHandler) {
          this.playerEl.removeEventListener("error", this.errorHandler);
        }
      },
      methods: {
        switchTab(id) {
          this.currentTab = id;
        },
        camParam(key) {
          return this.liveCam.find((p) => p.key === key) || null;
        },
        camVal(key) {
          const p = this.camParam(key);
          return p ? p.val : 0;
        },
        sendMotionPreset(name) {
          this.sendControl("motionPreset", { name, intensity: this.motionIntensity || 1 });
        },
        updateCam(key, evt) {
          const p = this.camParam(key);
          if (!p) return;
          const val = parseFloat(evt.target.value);
          if (Number.isNaN(val)) return;
          p.val = val;
          this.queueLiveParam(key, val);
        },
        async loadMediatorState() {
          if (typeof fetch !== "function") return;
          const keys = [...new Set([...this.liveVibe, ...this.liveCam].map((p) => p.key).concat(["seed", "prompt_mix"]))];
          try {
            const res = await fetch(`/api/mediator/state?keys=${encodeURIComponent(keys.join(","))}`, { cache: "no-store" });
            if (!res.ok) return;
            const data = await res.json();
            this.applyMediatorState(data);
          } catch (err) {
            console.warn("mediator state fetch failed", err);
          }
        },
        applyMediatorState(data) {
          if (!data || typeof data !== "object") return;
          const applyList = (list) => {
            list.forEach((p) => {
              if (data[p.key] != null && !Number.isNaN(Number(data[p.key]))) {
                p.val = Number(data[p.key]);
              }
            });
          };
          applyList(this.liveVibe);
          applyList(this.liveCam);
          if (data.prompt_mix != null) this.prompts.mix = Number(data.prompt_mix);
          if (data.lfo_sync) {
            this.lfos.forEach((l, idx) => {
              if (Array.isArray(data.lfo_sync) && data.lfo_sync[idx] != null) {
                l.sync = !!data.lfo_sync[idx];
              }
            });
          }
          if (data.seed != null) this.hud.seed = data.seed;
        },
        attachPlayer() {
          const video = document.getElementById("player");
          if (!video) return;
          if (this.playerEl && this.timeHandler) this.playerEl.removeEventListener("timeupdate", this.timeHandler);
          if (this.playerEl && this.errorHandler) this.playerEl.removeEventListener("error", this.errorHandler);
          this.playerEl = video;
          const hlsSource = this.streamSrc.includes("?") ? this.streamSrc + "&t=" + Date.now() : this.streamSrc + "?t=" + Date.now();
          if (this.hls && this.hls.destroy) {
            this.hls.destroy();
            this.hls = null;
          }
          if (video.canPlayType("application/vnd.apple.mpegurl")) {
            video.src = hlsSource;
            video.load();
            this.autoplayVideo(video);
          } else if (typeof Hls !== "undefined" && Hls.isSupported && Hls.isSupported()) {
            const hlsEvents = (Hls && Hls.Events) || { MANIFEST_PARSED: "manifest_parsed", ERROR: "error" };
            this.hls = new Hls({ liveSyncDurationCount: 3 });
            this.hls.loadSource(hlsSource);
            this.hls.attachMedia(video);
            if (this.hls.on) {
              this.hls.on(hlsEvents.MANIFEST_PARSED, () => this.autoplayVideo(video));
              this.hls.on(hlsEvents.ERROR, () => {
                setTimeout(() => this.attachPlayer(), 800);
              });
            }
          } else {
            video.src = hlsSource;
          }
          this.timeHandler = () => {
            if (!isNaN(video.currentTime)) {
              const t = video.currentTime;
              const m = Math.floor(t / 60);
              const s = (t % 60).toFixed(2).padStart(5, "0");
              this.timecode = `${String(m).padStart(2, "0")}:${s}`;
            }
          };
          this.errorHandler = () => {
            setTimeout(() => this.attachPlayer(), 800);
          };
          video.addEventListener("timeupdate", this.timeHandler);
          video.addEventListener("error", this.errorHandler);
          this.autoplayVideo(video);
        },
        autoplayVideo(video) {
          const el = video || this.playerEl;
          if (!el || typeof el.play !== "function") return;
          const p = el.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
        },
        ensureLivePlayback() {
          if (!this.playerEl) return;
          if (this.playerEl.paused || this.playerEl.readyState < 2) {
            this.autoplayVideo(this.playerEl);
          }
        },
        lfoTarget(lfo) {
          if (!lfo || !lfo.target) return null;
          return this.lfoTargets.find((t) => t.key === lfo.target) || null;
        },
        initLfoBase(lfo) {
          const target = this.lfoTarget(lfo);
          if (!target) return;
          if (lfo.base === null || lfo.base === undefined) {
            lfo.base = target.default != null ? target.default : (target.min + target.max) / 2;
          } else {
            lfo.base = this.clampVal(lfo.base, target.min, target.max);
          }
        },
        shapeValue(shape, phase) {
          const p = phase % (Math.PI * 2);
          if (shape === "Square") return Math.sin(p) >= 0 ? 1 : -1;
          if (shape === "Saw") return p / Math.PI - 1; // -1..1
          if (shape === "Triangle") return (2 * Math.asin(Math.sin(p))) / Math.PI;
          return Math.sin(p);
        },
        clampVal(v, min, max) {
          if (v === null || v === undefined || Number.isNaN(v)) return min;
          return Math.min(max, Math.max(min, v));
        },
        beatPos(sec) {
          if (!this.beatGrid.length) return 0;
          const max = this.beatGrid[this.beatGrid.length - 1] || 1;
          return Math.min(100, (sec / max) * 100);
        },
        async loadAudioAnalysis() {
          if (!this.audio.track) {
            this.audioStatus = "Set audio file first";
            return;
          }
          try {
            const peaksRes = await fetch("/api/audio/peaks", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ audioPath: this.audio.track, samples: 64 }),
            });
            if (peaksRes.ok) {
              const peaksJson = await peaksRes.json();
              if (Array.isArray(peaksJson.peaks)) this.waveformPeaks = peaksJson.peaks;
            }
            const beatsRes = await fetch("/api/audio/beats", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ audioPath: this.audio.track, bpm: this.audio.bpm || 120, bars: 16 }),
            });
            if (beatsRes.ok) {
              const beatsJson = await beatsRes.json();
              if (Array.isArray(beatsJson.beats)) this.beatGrid = beatsJson.beats;
              if (beatsJson.bpm) this.audio.bpm = beatsJson.bpm;
            }
            this.audioStatus = "Analysis loaded";
          } catch (err) {
            this.audioStatus = String(err);
          }
        },
        tapTempo() {
          const now = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
          if (this.lastTapTime) {
            const diff = now - this.lastTapTime;
            const bpm = 60000 / diff;
            if (bpm > 30 && bpm < 300) this.audio.bpm = Math.round(bpm);
          }
          this.lastTapTime = now;
        },
        speedToHz(speed, bpm) {
          if (!speed) return bpm / 60;
          const match = String(speed).match(/([0-9]+)\s*\/\s*([0-9]+)/);
          if (match) {
            const num = parseFloat(match[1]);
            const den = parseFloat(match[2]);
            if (num && den) {
              const beatsPerCycle = num / den;
              return (bpm / 60) / beatsPerCycle;
            }
          }
          if (/bar/i.test(speed)) {
            return (bpm / 60) / 4;
          }
          return bpm / 60;
        },
        runLfos(now = (typeof performance !== "undefined" && performance.now ? performance.now() : Date.now())) {
          if (this.lastLfoTick === null) {
            this.lastLfoTick = now;
            return;
          }
          const dtSec = (now - this.lastLfoTick) / 1000;
          this.lastLfoTick = now;
          if (dtSec <= 0) return;
          this.modTimeSec += dtSec;

          const payload = {};
          const bpmBase = this.audio.bpm || this.lfoBpm || 120;
          this.lfos.forEach((lfo) => {
            if (!lfo.on || !lfo.target) return;
            const target = this.lfoTarget(lfo);
            if (!target) return;
            const bpm = lfo.bpm || this.lfoBpm || 120;
            const depth = this.clampVal(lfo.depth ?? 0, 0, 1);
            const base = lfo.base == null ? (target.default ?? (target.min + target.max) / 2) : this.clampVal(lfo.base, target.min, target.max);
            lfo.base = base;
            const inc = dtSec * (bpm / 60) * Math.PI * 2;
            const phase = (lfo.phase || 0) + inc;
            lfo.phase = phase % (Math.PI * 2);
            const wave = this.shapeValue(lfo.shape, lfo.phase);
            const amp = depth * (target.max - target.min) / 2;
            const value = this.clampVal(base + wave * amp, target.min, target.max);
            payload[target.key] = value;
          });
          this.macrosRack.forEach((m) => {
            if (!m.on || !m.target) return;
            const target = this.lfoTargets.find((t) => t.key === m.target);
            if (!target) return;
            const depth = this.clampVal(m.depth ?? 0, 0, 1);
            const base = m.base == null ? (target.default ?? (target.min + target.max) / 2) : this.clampVal(m.base, target.min, target.max);
            m.base = base;
            const hz = this.speedToHz(m.speed || "1/4", bpmBase);
            const inc = dtSec * hz * Math.PI * 2;
            const phase = (m.phase || 0) + inc;
            m.phase = phase % (Math.PI * 2);
            const wave = this.shapeValue(m.shape, m.phase);
            const amp = depth * (target.max - target.min) / 2;
            const beatPos = (this.modTimeSec * bpmBase) / 60;
            if (beatPos >= (m.startBeat || 0) && beatPos <= (m.endBeat || 9999)) {
              const value = this.clampVal(base + wave * amp, target.min, target.max);
              payload[target.key] = value;
            }
          });
          if (Object.keys(payload).length) {
            this.sendControl("liveParam", payload);
          }
        },
        ensureAudioCtx() {
          if (this.audioCtx) return this.audioCtx;
          try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioCtx = new AudioContext();
          } catch (err) {
            console.warn("AudioContext not available", err);
          }
          return this.audioCtx;
        },
        async previewBand(band) {
          const ctx = this.ensureAudioCtx();
          if (!ctx || !this.audio.track) return;
          try {
            if (!this.audioBuffer) {
              const resp = await fetch(this.audio.track);
              const arr = await resp.arrayBuffer();
              this.audioBuffer = await ctx.decodeAudioData(arr);
            }
            const src = ctx.createBufferSource();
            src.buffer = this.audioBuffer;
            const filter = ctx.createBiquadFilter();
            filter.type = "bandpass";
            filter.frequency.value = Math.max(10, (band.freq_min + band.freq_max) / 2);
            filter.Q.value = Math.max(0.0001, filter.frequency.value / Math.max(1, band.freq_max - band.freq_min));
            src.connect(filter).connect(ctx.destination);
            src.start(0);
            setTimeout(() => {
              try {
                src.stop();
              } catch (_) {}
            }, 3000);
          } catch (err) {
            console.warn("preview failed", err);
          }
        },
        setupWS() {
          const url = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws";
          const connect = () => {
            this.ws = new WebSocket(url);
            this.ws.onopen = () => {
              this.wsStatus = "connected";
              console.log("WS connected");
            };
            this.ws.onclose = () => {
              this.wsStatus = "disconnected";
              setTimeout(connect, 1000);
            };
            this.ws.onmessage = (evt) => {
              try {
                const msg = JSON.parse(evt.data);
                if (msg.type === "event") console.log(msg.msg || "event");
                if (msg.type === "stream" && msg.src) {
                  this.streamSrc = msg.src + "?t=" + Date.now();
                  this.attachPlayer();
                }
                if (msg.type === "frame") {
                  this.refreshFrames();
                }
              } catch (_) {}
            };
          };
          connect();
        },
        sendControl(controlType, payload) {
          if (!this.ws || this.ws.readyState !== 1) return;
          const msg = { type: "control", controlType, payload };
          this.ws.send(JSON.stringify(msg));
        },
        updateParam(p, evt) {
          const val = parseFloat(evt.target.value);
          p.val = val;
          this.queueLiveParam(p.key, val);
        },
        setSource(key, source) {
          this.paramSources[key] = source;
          this.sendControl("paramSource", { key, source });
        },
        sourceTip(p) {
          const src = this.paramSources[p.key];
          if (src === "Beat") return "Beat/LFO";
          if (src === "MIDI") return "MIDI mapping";
          return "Manual";
        },
        sendPreset(name) {
          this.sendControl("motionPreset", { name });
        },
        midiTarget(key) {
          return this.lfoTargets.find((t) => t.key === key) || null;
        },
        updateMidiMapping(map) {
          // noop hook for now; v-model already updates
          return map;
        },
        setMorph(on) {
          this.prompts.morphOn = on;
          this.sendControl("prompts", { should_use_deforumation_prompts: on ? 1 : 0 });
          if (on) this.sendPromptsDebounced();
        },
        addMacro() {
          if (this.macrosRack.length >= 6) return;
          this.macrosRack.push({ on: true, target: "Vibe (CFG)", shape: "Sine", speed: "1/4 note", depth: 0.5, offset: 0.0, show: false });
        },
        addPromptSlot() {
          if (this.promptSchedule.length >= 12) return;
          const lastT = this.promptSchedule.length ? Math.max(...this.promptSchedule.map((s) => s.t || 0)) : 0;
          this.promptSchedule.push({ t: lastT + 1, mix: this.prompts.mix });
          this.updatePromptGraph();
        },
        addAudioMapping() {
          this.audioMappings.push({ param: "", freq_min: 60, freq_max: 500, out_min: 0, out_max: 1 });
        },
        queueLiveParam(key, val) {
          const now = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
          const last = this.lastParamSent[key] || 0;
          this.liveParamPending[key] = val;
          if (now - last > this.controlDelayMs) {
            this.lastParamSent[key] = now;
            this.sendControl("liveParam", { [key]: val });
            return;
          }
          clearTimeout(this.liveParamTimers[key]);
          this.liveParamTimers[key] = setTimeout(() => {
            const v = this.liveParamPending[key];
            delete this.liveParamPending[key];
            this.lastParamSent[key] = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
            this.sendControl("liveParam", { [key]: v });
          }, this.controlDelayMs);
        },
        sendPrompts() {
          const payload = {
            positive_prompt_1: this.prompts.posA,
            positive_prompt_2: this.prompts.posB,
            negative_prompt: this.prompts.neg,
            prompt_mix: this.prompts.mix,
            should_use_deforumation_prompts: this.prompts.morphOn ? 1 : 0,
          };
          if (this.promptSchedule.length) {
            payload.prompt_schedule = this.promptSchedule
              .filter((s) => s && s.t != null && s.mix != null)
              .map((s) => ({ t: Number(s.t), mix: Number(s.mix) }));
          }
          this.sendControl("prompts", payload);
        },
        updatePromptGraph() {
          const sorted = [...this.promptSchedule]
            .filter((s) => s && s.t != null && s.mix != null)
            .sort((a, b) => a.t - b.t);
          const pts = [];
          const maxT = sorted.length ? Math.max(...sorted.map((s) => s.t)) || 1 : 1;
          sorted.forEach((s) => {
            const x = Math.min(100, (s.t / maxT) * 100);
            const y = 50 - s.mix * 50;
            pts.push(`${x},${y}`);
          });
          this.promptPolyline = pts.join(" ");
          this.promptSchedule = sorted;
        },
        sendPromptsDebounced() {
          clearTimeout(this.promptsTimer);
          this.promptsTimer = setTimeout(() => this.sendPrompts(), this.controlDelayMs);
        },
        removePromptSlot(idx) {
          this.promptSchedule.splice(idx, 1);
          this.updatePromptGraph();
          this.sendPromptsDebounced();
        },
        sendControlNet(slot) {
          if (!slot || !slot.id) return;
          const payload = {
            slot: slot.id,
            weight: slot.weight,
            enabled: slot.enabled ? 1 : 0,
            bypass: slot.bypass ? 1 : 0,
          };
          this.sendControl("controlnet", payload);
        },
        pullLfoState(state) {
          if (!state) return;
          this.lfos.forEach((l) => {
            if (state[l.id]) {
              const s = state[l.id];
              if (s.base != null) l.base = s.base;
              if (s.depth != null) l.depth = s.depth;
              if (s.sync != null) l.sync = !!s.sync;
              if (s.target) l.target = s.target;
            }
          });
        },
        async refreshFrames() {
          if (typeof fetch !== "function") return;
          try {
            const res = await fetch("/api/frames?limit=10", { cache: "no-store" });
            if (!res.ok) return;
            const json = await res.json();
            if (Array.isArray(json.items)) {
              this.thumbs = json.items.map((item) => {
                if (typeof item === "string") {
                  return { src: item, name: item.split("/").pop(), frame: this.parseFrameNumber(item) };
                }
                const src = item.src || item.url || item.path || "";
                const name = item.name || src.split("/").pop();
                const frame = item.frame != null ? item.frame : this.parseFrameNumber(name || src);
                return { src, name, frame };
              });
            }
          } catch (e) {
            console.warn("frames fetch failed", e);
          }
        },
        parseFrameNumber(name) {
          if (!name) return null;
          const match = String(name).match(/(\d{3,})/);
          return match ? parseInt(match.pop(), 10) : null;
        },
        async runAudioMod() {
          if (!this.audio.track) {
            this.audioStatus = "Set audio file first";
            return;
          }
          const mappings = this.audioMappings
            .filter((m) => m.param && !Number.isNaN(m.freq_min) && !Number.isNaN(m.freq_max))
            .map((m) => ({
              param: m.param,
              freq_min: m.freq_min,
              freq_max: m.freq_max,
              out_min: m.out_min ?? 0,
              out_max: m.out_max ?? 1,
            }));
          if (!mappings.length) {
            this.audioStatus = "Add at least one mapping";
            return;
          }
          try {
            const res = await fetch("/api/audio-map", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                audioPath: this.audio.track,
                fps: this.stats.fps || 24,
                mappings,
                bands: this.bands.map((b) => ({
                  param: b.param,
                  freq_min: b.freq_min,
                  freq_max: b.freq_max,
                  intensity: b.intensity,
                })),
                live: true,
              }),
            });
            const json = await res.json();
            if (!res.ok || json.error) {
              this.audioStatus = json.error || "Audio processing failed";
            } else {
              this.audioStatus = json.ok ? "Audio sent to mediator" : "Audio processing finished with errors";
            }
          } catch (err) {
            this.audioStatus = String(err);
          }
        },
        frameLabel(t) {
          if (!t) return "?";
          if (t.frame != null && !isNaN(t.frame)) return t.frame;
          if (t.name) return t.name.replace(/\.[^.]+$/, "");
          return t.src || "?";
        },
        async scanMidi() {
          if (!navigator.requestMIDIAccess) {
            this.midi.supported = false;
            return;
          }
          try {
            const access = await navigator.requestMIDIAccess({ sysex: false });
            const devices = [];
            access.inputs.forEach((input) => {
              devices.push({ id: input.id, name: input.name });
              input.onmidimessage = (msg) => this.handleMidi(input, msg);
            });
            this.midi.devices = devices;
            if (!this.midi.selected && devices.length) this.midi.selected = devices[0].id;
          } catch (e) {
            this.midiStatus = "MIDI not available";
          }
        },
        handleMidi(input, msg) {
          const [status, cc, value] = msg.data;
          const isCC = (status & 0xf0) === 0xb0;
          if (!isCC) return;
          const mapping = this.midi.mappings.find((m) => m.cc === cc);
          const norm = value / 127;
          if (mapping && mapping.key) {
            const target = this.midiTarget(mapping.key);
            if (target) {
              const scaled = target.min + norm * (target.max - target.min);
              this.sendControl("liveParam", { [target.key]: scaled });
            } else {
              this.sendControl("liveParam", { [mapping.key]: norm });
            }
          }
        },
      },
    }).mount("#app");
  </script>
</body>
</html>
