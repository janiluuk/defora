<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Defora Web</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/vue@3.4.27/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --bg: #06080f;
      --panel: #0f1422;
      --panel-2: #11182d;
      --border: #1f2a44;
      --glow1: #ff53d9;
      --glow2: #2de2ff;
      --text: #e8edf7;
      --muted: #9bb1d0;
      --success: #5af2a9;
      --danger: #ff4d6d;
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", Arial, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(255, 83, 217, 0.12), transparent 25%),
                  radial-gradient(circle at 80% 0%, rgba(45, 226, 255, 0.12), transparent 25%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 8px 16px;
      background: rgba(13, 18, 34, 0.8);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(6px);
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 16px;
      align-items: center;
    }
    .brand { display: none; }
    .tabs { display: flex; gap: 6px; flex-wrap: wrap; justify-content: flex-start; }
    .tab { padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border); background: #0f172a; color: var(--muted); cursor: pointer; }
    .tab.active { border-color: var(--glow2); color: var(--text); box-shadow: 0 6px 20px rgba(45,226,255,0.12); }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 999px; border: 1px solid var(--border); background: #11182d; color: var(--muted); font-size: 12px; }
    .pill .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); box-shadow: 0 0 8px var(--success); }
    .pill.danger .dot { background: var(--danger); box-shadow: 0 0 8px var(--danger); }
    .btn { background: linear-gradient(90deg, var(--glow1), var(--glow2)); color: #0a0c12; border: none; border-radius: 999px; padding: 8px 12px; font-weight: 700; cursor: pointer; }
    .btn.ghost { background: #0f172a; color: var(--text); border: 1px solid var(--border); }
    .layout { flex: 1; display: grid; grid-template-columns: 1.8fr 1fr; gap: 10px; padding: 10px; }
    .preview { display: flex; flex-direction: column; gap: 0; }
    .video-wrap { position: relative; border-radius: 8px; overflow: hidden; background: #000; aspect-ratio: 16 / 9; width: 100%; }
    video { width: 100%; height: 100%; display: block; background: #000; object-fit: contain; }
    .overlay { position: absolute; left: 0; right: 0; top: 0; display: flex; justify-content: space-between; padding: 10px 12px; background: linear-gradient(180deg, rgba(0,0,0,0.7), transparent); font-size: 13px; font-weight: 600; color: #fff; }
    .timeline { background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 8px; }
    .thumbs { display: flex; gap: 8px; overflow-x: auto; margin-bottom: 6px; padding-bottom: 4px; }
    .thumb-card { position: relative; border-radius: 10px; overflow: hidden; border: 1px solid var(--border); background: #0b0f1c; box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
    .thumb { width: 92px; height: 54px; display: block; background: #11182a; object-fit: cover; }
    .thumb-label { position: absolute; left: 0; right: 0; bottom: 0; padding: 3px 6px; font-size: 11px; color: var(--text); background: linear-gradient(180deg, transparent, rgba(0,0,0,0.7)); }
    .wave { height: 40px; border-radius: 8px; background: linear-gradient(90deg, rgba(255,83,217,0.2), rgba(45,226,255,0.2)); border: 1px solid var(--border); }
    .rack { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .rack h3 { margin: 0 0 8px 0; }
    .slider-row { display: grid; grid-template-columns: 1.1fr 1fr; gap: 8px; align-items: center; margin: 8px 0; font-size: 13px; color: var(--muted); }
    .slider-row input[type=range] { width: 100%; accent-color: var(--glow2); }
    .source { display: inline-flex; gap: 6px; font-size: 12px; color: var(--muted); align-items: center; }
    .chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { padding: 8px 12px; border-radius: 999px; border: 1px solid var(--border); background: #11182a; color: var(--text); cursor: pointer; }
    .chip.active { border-color: var(--glow2); color: var(--glow2); }
    .context { grid-column: 1 / span 2; background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; }
    .context h4 { margin: 0 0 6px 0; }
    .table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text); }
    .table th, .table td { padding: 6px 8px; border-bottom: 1px solid var(--border); text-align: left; }
    .xy-pad { width: 140px; height: 140px; border-radius: 12px; border: 1px solid var(--border); background: #0f172a; position: relative; cursor: crosshair; user-select: none; }
    .xy-dot { position: absolute; width: 12px; height: 12px; border-radius: 50%; background: var(--glow2); box-shadow: 0 0 10px var(--glow2); }
    .lfo-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; }
    .lfo-card { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: #0e1322; box-shadow: 0 8px 18px rgba(0,0,0,0.28); }
    .lfo-card h4 { margin: 0 0 6px 0; display: flex; align-items: center; justify-content: space-between; font-size: 14px; }
    .lfo-card .meta { font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    .lfo-card select, .lfo-card input[type=number] { width: 100%; padding: 6px; border-radius: 8px; border: 1px solid var(--border); background: #0f172a; color: var(--text); }
    .lfo-card .switch { display: inline-flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px; color: var(--muted); }
    .audio-map-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: 10px; }
    .audio-map-card { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #0f172a; }
    .framesync-panel { background: #061726; border: 1px solid #0c2c3f; border-radius: 10px; padding: 10px; box-shadow: inset 0 0 0 1px rgba(11, 72, 104, 0.35); }
    .framesync-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; color: #cde5f7; font-weight: 600; letter-spacing: 0.6px; }
    .framesync-title { font-size: 18px; }
    .framesync-accent { color: #ff8a1a; }
    .framesync-graph { margin-top: 10px; background: #031b2d; border: 1px solid #0c3048; border-radius: 8px; padding: 6px 10px; }
    .framesync-axis { display: grid; grid-template-columns: repeat(12, 1fr); gap: 0; margin-top: 6px; font-size: 10px; color: #7fb3d6; }
    .framesync-axis span { text-align: center; }
    .framesync-row { display: grid; grid-template-columns: 1.1fr 2fr 1.2fr 1.2fr; gap: 12px; margin-top: 12px; }
    .framesync-stack { display: grid; gap: 10px; }
    .framesync-subtitle { font-size: 12px; color: #9bc4e2; margin-bottom: 6px; letter-spacing: 0.3px; }
    .framesync-list { font-size: 12px; color: #cfe5f5; }
    .framesync-list .item { padding: 4px 0; border-bottom: 1px solid rgba(12, 48, 72, 0.6); }
    .framesync-list .item:last-child { border-bottom: none; }
    .framesync-select, .framesync-input { width: 100%; padding: 6px; background: #03192a; border: 1px solid #0c3048; border-radius: 4px; color: #cfe5f5; font-size: 12px; }
    .framesync-input[type="range"] { accent-color: #ff8a1a; }
    .framesync-gradient-bar { background: linear-gradient(90deg, #ff8a1a, #2de2ff); height: 24px; border-radius: 6px; }
    .xy-dot.framesync { background: #ff8a1a; box-shadow: 0 0 10px #ff8a1a; }
    .framesync-buttons { display: grid; grid-template-columns: repeat(auto-fit, minmax(64px, 1fr)); gap: 6px; }
    .framesync-button { background: #061b2d; border: 1px solid #0f3c5c; color: #cfe5f5; font-size: 11px; padding: 6px 4px; text-align: center; border-radius: 4px; cursor: pointer; }
    .framesync-button.active { border-color: #ff8a1a; color: #ffbf80; }
    .framesync-metric { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 12px; color: #cfe5f5; }
    .framesync-metric span { display: block; color: #7fb3d6; font-size: 10px; }
    .framesync-wave-shapes { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; margin-top: 6px; }
    .framesync-wave { background: #031b2d; border: 1px solid #0c3048; border-radius: 6px; padding: 6px; text-align: center; font-size: 10px; color: #cfe5f5; }
    .framesync-wave svg { width: 100%; height: 40px; display: block; margin-bottom: 4px; }
    .framesync-footer { margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; }
    .framesync-toggle { display: flex; align-items: center; gap: 6px; font-size: 11px; color: #cfe5f5; }
    .framesync-dot { width: 10px; height: 10px; border-radius: 50%; background: #ff8a1a; box-shadow: 0 0 8px rgba(255, 138, 26, 0.6); }
    .compact-panel { background: #0f1422; border: 1px solid var(--border); border-radius: 12px; padding: 10px; display: grid; gap: 8px; }
    .compact-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 8px; }
    .mod-row { display: grid; grid-template-columns: 24px 1.2fr 1fr 70px 70px 1fr 36px; gap: 6px; align-items: center; font-size: 12px; }
    .mod-row .select, .mod-row input { width: 100%; }
    .mod-row .chip { padding: 6px 8px; font-size: 11px; }
    .mod-row button { background: #0f172a; border: 1px solid var(--border); color: var(--text); border-radius: 8px; padding: 4px 6px; cursor: pointer; }
    .mod-header { display: flex; align-items: center; justify-content: space-between; font-size: 12px; color: var(--muted); }
    .mod-preview { grid-column: 2 / span 5; background: #0c1324; border: 1px solid var(--border); border-radius: 8px; padding: 6px; }
    .mod-preview svg { width: 100%; height: 36px; display: block; }
    .mod-subheader { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .fs-card { background: #0b1526; border: 1px solid #13233d; border-radius: 12px; padding: 10px; box-shadow: inset 0 0 0 1px rgba(18, 44, 72, 0.45); }
    .fs-card h4 { margin: 0 0 8px 0; font-size: 13px; color: #cfe5f5; letter-spacing: 0.3px; }
    .fs-toolbar { display: flex; align-items: center; justify-content: space-between; gap: 8px; font-size: 12px; color: #9bc4e2; }
    .fs-field { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; align-items: center; font-size: 12px; color: #cfe5f5; }
    .fs-input, .fs-select { width: 100%; padding: 6px; background: #061b2d; border: 1px solid #13324c; border-radius: 6px; color: #e8edf7; font-size: 12px; }
    .fs-button { background: #0b1f34; border: 1px solid #173753; color: #cfe5f5; border-radius: 999px; padding: 6px 12px; font-size: 11px; cursor: pointer; }
    .fs-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; margin-top: 8px; }
    .fs-chip { background: #071a2b; border: 1px solid #173753; color: #cfe5f5; border-radius: 999px; padding: 4px 10px; font-size: 11px; cursor: pointer; }
    .fs-row { display: grid; grid-template-columns: 24px 1.2fr 1fr 70px 70px 1fr 36px; gap: 6px; align-items: center; font-size: 12px; color: #cfe5f5; }
    .fs-row input[type=number] { background: #061b2d; border: 1px solid #13324c; border-radius: 6px; color: #e8edf7; padding: 4px 6px; }
    .fs-row select { background: #061b2d; border: 1px solid #13324c; border-radius: 6px; color: #e8edf7; padding: 4px 6px; }
    .fs-row button { background: #0b1f34; border: 1px solid #173753; color: #cfe5f5; border-radius: 8px; padding: 4px 6px; cursor: pointer; }
    /* Custom video controls with FrameSync styling */
    .preview-bar-container { margin-top: 4px; background: #061726; border: 1px solid #0c2c3f; border-radius: 6px; overflow: hidden; }
    .preview-bar-header { display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; background: #0b1526; border-bottom: 1px solid #0c2c3f; }
    .preview-bar-title { font-size: 11px; color: #9bc4e2; font-weight: 600; }
    .preview-bar-toggle { background: transparent; border: 1px solid #173753; color: #cfe5f5; border-radius: 4px; padding: 2px 6px; font-size: 10px; cursor: pointer; }
    .preview-bar-toggle:hover { border-color: #ff8a1a; color: #ff8a1a; }
    .preview-bar { display: flex; gap: 4px; overflow-x: auto; padding: 6px; max-height: 70px; }
    .preview-bar.collapsed { display: none; }
    .preview-bar::-webkit-scrollbar { height: 4px; }
    .preview-bar::-webkit-scrollbar-track { background: #061726; }
    .preview-bar::-webkit-scrollbar-thumb { background: #173753; border-radius: 2px; }
    .preview-bar::-webkit-scrollbar-thumb:hover { background: #ff8a1a; }
    .thumb-card { position: relative; border-radius: 4px; overflow: hidden; border: 1px solid #0c2c3f; background: #0b0f1c; flex-shrink: 0; }
    .thumb { width: 80px; height: 45px; display: block; background: #11182a; object-fit: cover; }
    .thumb-label { position: absolute; left: 0; right: 0; bottom: 0; padding: 2px 4px; font-size: 9px; color: var(--text); background: linear-gradient(180deg, transparent, rgba(0,0,0,0.8)); }
    .video-controls-panel { background: linear-gradient(135deg, #0b1f34 0%, #061726 100%); border: 1px solid #173753; border-radius: 8px; padding: 8px 12px; margin-top: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .video-controls { display: flex; gap: 8px; align-items: center; justify-content: center; }
    .control-btn { background: #0b1f34; border: 1px solid #173753; color: #cfe5f5; border-radius: 6px; padding: 6px 16px; font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.2s; min-width: 90px; justify-content: center; font-weight: 600; }
    .control-btn:hover { border-color: #ff8a1a; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(255, 138, 26, 0.3); }
    .control-btn.playing { border-color: #5af2a9; background: rgba(90, 242, 169, 0.12); color: #5af2a9; }
    .control-btn.recording { border-color: #ff4d6d; background: rgba(255, 77, 109, 0.12); color: #ff4d6d; animation: pulse 1.5s ease-in-out infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    .stream-link { background: #031b2d; border: 1px solid #0c3048; border-radius: 4px; padding: 4px 8px; font-size: 10px; color: #cfe5f5; display: flex; align-items: center; gap: 6px; margin-top: 4px; justify-content: center; }
    .stream-link a { color: #ff8a1a; text-decoration: none; }
    .stream-link a:hover { text-decoration: underline; }
    .thumb-placeholder { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #0b1526 0%, #061726 100%); }
    .thumb-placeholder svg { width: 30px; height: 30px; opacity: 0.3; }
    video::-webkit-media-controls { display: none !important; }
    video::-webkit-media-controls-enclosure { display: none !important; }
    @media (max-width: 1100px) {
      .layout { grid-template-columns: 1fr; }
      .context { grid-column: 1; }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="tabs">
        <button class="tab" v-for="tab in tabs" :key="tab.id" :class="{active: currentTab===tab.id}" @click="switchTab(tab.id)">
          {{ tab.label }}
        </button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
        <button class="btn" @click="sendControl('transport',{action:'toggle'})">‚èØ</button>
        <button class="btn ghost" @click="sendControl('transport',{action:'stop'})">‚èπ</button>
        <button class="btn ghost" @click="sendControl('transport',{action:'record'})">‚óè Rec</button>
        <div class="pill"><span>FPS</span><strong>{{ stats.fps }}</strong></div>
        <div class="pill"><span>Lat</span><strong>{{ stats.lat }}ms</strong></div>
      </div>
    </header>

    <div class="layout">
      <!-- Left: video + mini timeline -->
      <div class="preview">
        <div class="video-wrap">
          <video id="player" ref="videoPlayer" autoplay muted playsinline></video>
          <div class="overlay">
            <div style="font-size: 14px; font-weight: 700;">Defora ¬∑ Session: {{ session }}</div>
            <div>Seed {{ hud.seed }}</div>
          </div>
        </div>
        
        <!-- Preview bar right below video -->
        <div class="preview-bar-container">
          <div class="preview-bar-header">
            <div class="preview-bar-title">üìΩÔ∏è Preview Frames</div>
            <button class="preview-bar-toggle" @click="previewBarCollapsed = !previewBarCollapsed">
              {{ previewBarCollapsed ? '‚ñº Show' : '‚ñ≤ Hide' }}
            </button>
          </div>
          <div class="preview-bar" :class="{collapsed: previewBarCollapsed}">
            <template v-if="thumbs.length">
              <div class="thumb-card" v-for="t in thumbs" :key="t.src">
                <img class="thumb" :src="t.src" loading="lazy" :alt="'frame '+frameLabel(t)" />
                <div class="thumb-label">#{{ frameLabel(t) }}</div>
              </div>
            </template>
            <template v-else>
              <div class="thumb-card" v-for="n in 6" :key="'ph'+n">
                <div class="thumb thumb-placeholder">
                  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="#ff8a1a" stroke-width="2"/>
                    <path d="M12 8V12L15 15" stroke="#ff8a1a" stroke-width="2" stroke-linecap="round"/>
                  </svg>
                </div>
                <div class="thumb-label">waiting‚Ä¶</div>
              </div>
            </template>
          </div>
        </div>
        
        <!-- Stylish controls panel below preview bar -->
        <div class="video-controls-panel">
          <div class="video-controls">
            <button class="control-btn" @click="togglePlayPause" :class="{playing: isPlaying}">
              <span v-if="isPlaying">‚è∏</span>
              <span v-else>‚ñ∂</span>
              {{ isPlaying ? 'Pause' : 'Play' }}
            </button>
            <button class="control-btn" @click="stopVideo">
              ‚èπ Stop
            </button>
            <button class="control-btn" @click="toggleRecord" :class="{recording: isRecording}">
              <span v-if="isRecording">‚è∫</span>
              <span v-else>‚óè</span>
              {{ isRecording ? 'Rec' : 'Record' }}
            </button>
          </div>
          <div class="stream-link" v-if="streamUrl">
            <span>üîó Stream:</span>
            <a :href="streamUrl" target="_blank">{{ streamUrl }}</a>
          </div>
        </div>
        
        <div class="timeline" style="margin-top: 4px;">
          <div class="wave"></div>
        </div>
      </div>

      <!-- Right: control rack per tab -->
      <div>
        <div v-if="currentTab==='LIVE'">
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üé® Vibe & <span class="framesync-accent">Style</span></div>
              </div>
              <div class="framesync-row" style="grid-template-columns: repeat(2, 1fr); gap:10px; margin-top:12px;">
                <div class="framesync-stack" v-for="p in liveVibe" :key="p.key">
                  <div class="framesync-subtitle">{{ p.label }}</div>
                  <input type="range" :min="p.min" :max="p.max" :step="p.step" :value="p.val" @input="updateParam(p,$event)" class="framesync-input">
                  <div class="framesync-footer" style="gap:4px;">
                    <button class="framesync-button" :class="{active: paramSources[p.key]==='Manual'}" @click="setSource(p.key,'Manual')">Manual</button>
                    <button class="framesync-button" :class="{active: paramSources[p.key]==='Beat'}" @click="setSource(p.key,'Beat')">üåä Beat</button>
                    <button class="framesync-button" :class="{active: paramSources[p.key]==='MIDI'}" @click="setSource(p.key,'MIDI')">üéõ MIDI</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üìπ <span class="framesync-accent">Camera</span></div>
              </div>
              <div class="framesync-row" style="grid-template-columns: repeat(2, 1fr); gap:10px; margin-top:12px;">
                <div class="framesync-stack" v-for="p in liveCam" :key="p.key">
                  <div class="framesync-subtitle">{{ p.label }}</div>
                  <input type="range" :min="p.min" :max="p.max" :step="p.step" :value="p.val" @input="updateParam(p,$event)" class="framesync-input">
                  <div class="framesync-footer" style="gap:4px;" v-if="p.sourceable">
                    <button class="framesync-button" :class="{active: paramSources[p.key]==='Manual'}" @click="setSource(p.key,'Manual')">Manual</button>
                    <button class="framesync-button" :class="{active: paramSources[p.key]==='Beat'}" @click="setSource(p.key,'Beat')">üåä Beat</button>
                    <button class="framesync-button" :class="{active: paramSources[p.key]==='MIDI'}" @click="setSource(p.key,'MIDI')">üéõ MIDI</button>
                  </div>
                </div>
              </div>
              <div class="framesync-subtitle" style="margin-top:16px;">Motion Presets</div>
              <div class="framesync-footer" style="margin-top:8px;">
                <button class="framesync-button" v-for="p in Object.keys(motionPresets)" :key="p" @click="sendPreset(p)">{{ p }}</button>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='PROMPTS'">
          <!-- Unified Morph Control Panel -->
          <div class="rack">
            <div class="framesync-panel" style="background: linear-gradient(135deg, #061726 0%, #0b1526 100%); border: 2px solid #173753;">
              <div class="framesync-header" style="border-bottom: 1px solid #173753; padding-bottom: 12px;">
                <div class="framesync-title" style="font-size: 20px;">üéöÔ∏è Morph <span class="framesync-accent">Control</span></div>
                <div style="display:flex; gap:8px; align-items:center;">
                  <button class="framesync-button" :class="{active: prompts.morphOn}" @click="setMorph(!prompts.morphOn)" style="padding:6px 16px;">
                    {{ prompts.morphOn ? '‚òë Enabled' : '‚òê Disabled' }}
                  </button>
                  <button class="framesync-button" @click="applyLoras" style="padding:6px 16px;">‚úì Apply All</button>
                </div>
              </div>
              
              <!-- Main Crossfader Section with A/B Groups -->
              <div style="margin-top:20px; display:grid; grid-template-columns: 1fr 2fr 1fr; gap:16px; align-items:stretch;">
                
                <!-- Group A -->
                <div style="background: linear-gradient(135deg, rgba(90, 242, 169, 0.08) 0%, rgba(90, 242, 169, 0.02) 100%); border: 2px solid rgba(90, 242, 169, 0.3); border-radius:12px; padding:14px; min-height: 240px; display: flex; flex-direction: column;">
                  <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px;">
                    <div style="font-size:16px; color:#5af2a9; font-weight:700; letter-spacing:1px;">‚óÄ GROUP A</div>
                    <div style="font-size:24px; font-weight:900; color:#5af2a9; opacity:0.8;">{{ Math.round((1 - prompts.crossfaderValue) * 100) }}%</div>
                  </div>
                  
                  <div style="flex:1; display:flex; flex-direction:column; gap:8px;">
                    <div v-for="lora in loras.groupA.slice(0, 3)" :key="'a-'+lora.id" 
                         style="background:#0b1526; border:1px solid #5af2a9; border-radius:8px; padding:8px;">
                      <div style="font-size:12px; color:#cfe5f5; font-weight:600; margin-bottom:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                        {{ lora.name }}
                      </div>
                      <div style="display:flex; justify-content:space-between; align-items:center; font-size:10px;">
                        <span style="color:#7fb3d6;">Base: {{ lora.strength.toFixed(1) }}</span>
                        <span style="color:#5af2a9; font-weight:700;">‚Üí {{ (lora.strength * (1 - prompts.crossfaderValue)).toFixed(2) }}</span>
                      </div>
                    </div>
                    <div v-if="loras.groupA.length === 0" style="flex:1; display:flex; align-items:center; justify-content:center; color:#7fb3d6; font-size:11px; text-align:center;">
                      No LoRAs in Group A<br/>Add from LORA tab
                    </div>
                    <div v-else-if="loras.groupA.length > 3" style="font-size:10px; color:#9bc4e2; text-align:center; padding:4px;">
                      +{{ loras.groupA.length - 3 }} more
                    </div>
                  </div>
                </div>
                
                <!-- Center: Crossfader -->
                <div style="background: linear-gradient(180deg, #0f1422 0%, #061726 100%); border: 2px solid #ff8a1a; border-radius:16px; padding:20px; display:flex; flex-direction:column; justify-content:center; box-shadow: 0 8px 32px rgba(255, 138, 26, 0.15);">
                  <div style="text-align:center; margin-bottom:16px;">
                    <div style="font-size:11px; color:#9bc4e2; letter-spacing:2px; margin-bottom:8px;">CROSSFADER</div>
                    <div style="font-size:42px; font-weight:900; background: linear-gradient(90deg, #5af2a9 0%, #ff8a1a 50%, #2de2ff 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing:-2px;">
                      {{ prompts.crossfaderValue.toFixed(2) }}
                    </div>
                  </div>
                  
                  <!-- Large Crossfader Slider -->
                  <div style="position:relative; padding:12px 0;">
                    <div style="position:absolute; top:0; left:0; right:0; height:8px; background: linear-gradient(90deg, #5af2a9 0%, #ff8a1a 50%, #2de2ff 100%); border-radius:4px; opacity:0.3;"></div>
                    <input type="range" min="0" max="1" step="0.001" v-model.number="prompts.crossfaderValue" @input="updateCrossfader" 
                           class="framesync-input" 
                           style="width:100%; height:32px; cursor:grab; accent-color:#ff8a1a; position:relative;">
                  </div>
                  
                  <div style="display:flex; justify-content:space-between; margin-top:12px; font-size:13px; font-weight:700;">
                    <span style="color:#5af2a9;">A</span>
                    <span style="color:#ff8a1a;">{{ Math.round(prompts.crossfaderValue * 100) }}% ‚Üí</span>
                    <span style="color:#2de2ff;">B</span>
                  </div>
                  
                  <!-- Visual Indicator -->
                  <div style="margin-top:16px; height:6px; background:#0b1526; border-radius:3px; overflow:hidden; position:relative;">
                    <div style="position:absolute; left:0; top:0; bottom:0; background:#5af2a9; transition: width 0.1s;" :style="{width: (100 - prompts.crossfaderValue * 100) + '%'}"></div>
                    <div style="position:absolute; right:0; top:0; bottom:0; background:#2de2ff; transition: width 0.1s;" :style="{width: (prompts.crossfaderValue * 100) + '%'}"></div>
                  </div>
                </div>
                
                <!-- Group B -->
                <div style="background: linear-gradient(135deg, rgba(45, 226, 255, 0.08) 0%, rgba(45, 226, 255, 0.02) 100%); border: 2px solid rgba(45, 226, 255, 0.3); border-radius:12px; padding:14px; min-height: 240px; display: flex; flex-direction: column;">
                  <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px;">
                    <div style="font-size:16px; color:#2de2ff; font-weight:700; letter-spacing:1px;">GROUP B ‚ñ∂</div>
                    <div style="font-size:24px; font-weight:900; color:#2de2ff; opacity:0.8;">{{ Math.round(prompts.crossfaderValue * 100) }}%</div>
                  </div>
                  
                  <div style="flex:1; display:flex; flex-direction:column; gap:8px;">
                    <div v-for="lora in loras.groupB.slice(0, 3)" :key="'b-'+lora.id" 
                         style="background:#0b1526; border:1px solid #2de2ff; border-radius:8px; padding:8px;">
                      <div style="font-size:12px; color:#cfe5f5; font-weight:600; margin-bottom:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                        {{ lora.name }}
                      </div>
                      <div style="display:flex; justify-content:space-between; align-items:center; font-size:10px;">
                        <span style="color:#7fb3d6;">Base: {{ lora.strength.toFixed(1) }}</span>
                        <span style="color:#2de2ff; font-weight:700;">‚Üí {{ (lora.strength * prompts.crossfaderValue).toFixed(2) }}</span>
                      </div>
                    </div>
                    <div v-if="loras.groupB.length === 0" style="flex:1; display:flex; align-items:center; justify-content:center; color:#7fb3d6; font-size:11px; text-align:center;">
                      No LoRAs in Group B<br/>Add from LORA tab
                    </div>
                    <div v-else-if="loras.groupB.length > 3" style="font-size:10px; color:#9bc4e2; text-align:center; padding:4px;">
                      +{{ loras.groupB.length - 3 }} more
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Prompt Inputs Section -->
          <div class="rack">
            <div class="framesync-panel">
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
                <div>
                  <div class="framesync-subtitle" style="margin-bottom:8px; color:#5af2a9;">‚úçÔ∏è Positive Prompt</div>
                  <textarea class="framesync-input" v-model="prompts.pos" @change="sendPrompts" placeholder="Enter positive prompt..." 
                            style="padding:10px; width:100%; min-height:80px; resize:vertical; font-family: inherit;"></textarea>
                </div>
                <div>
                  <div class="framesync-subtitle" style="margin-bottom:8px; color:#ff4d6d;">üö´ Negative Prompt</div>
                  <textarea class="framesync-input" v-model="prompts.neg" @change="sendPrompts" placeholder="Enter negative prompt..." 
                            style="padding:10px; width:100%; min-height:80px; resize:vertical; font-family: inherit;"></textarea>
                </div>
              </div>
              <div class="framesync-footer" style="margin-top:12px; justify-content:center;">
                <button class="framesync-button" @click="sendPrompts" style="padding:8px 24px; font-size:14px;">üíæ Update Prompts</button>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='LORA'">
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üìö LoRA <span class="framesync-accent">Browser</span></div>
                <button class="framesync-button" @click="refreshLoras">üîÑ Refresh</button>
              </div>
              <div style="margin-top:12px; display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:12px; max-height:400px; overflow-y:auto;">
                <div v-for="lora in loras.available" :key="lora.id" 
                     style="background:#0b1526; border:1px solid #13233d; border-radius:10px; overflow:hidden; cursor:pointer;"
                     @click="toggleLoraSelection(lora)">
                  <div style="position:relative; width:100%; height:180px; background:#031b2d;">
                    <img v-if="lora.thumbnail" :src="lora.thumbnail" style="width:100%; height:100%; object-fit:cover;" :alt="lora.name" />
                    <div v-else style="display:flex; align-items:center; justify-content:center; height:100%; color:#7fb3d6;">
                      <svg viewBox="0 0 24 24" style="width:48px; height:48px; opacity:0.3;" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="3" y="3" width="18" height="18" stroke="currentColor" stroke-width="2" rx="2"/>
                        <circle cx="8" cy="8" r="2" fill="currentColor"/>
                        <path d="M3 15 L8 10 L12 14 L17 9 L21 13 V21 H3 Z" fill="currentColor" opacity="0.5"/>
                      </svg>
                    </div>
                    <div v-if="lora.selected" style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.8); border:1px solid #ff8a1a; border-radius:4px; padding:4px 8px; font-size:10px; color:#ff8a1a; font-weight:700;">
                      ‚úì {{ lora.group }}
                    </div>
                  </div>
                  <div style="padding:10px;">
                    <div style="font-size:13px; color:#cfe5f5; font-weight:600; margin-bottom:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                      {{ lora.name }}
                    </div>
                    <div style="font-size:10px; color:#7fb3d6; margin-bottom:8px;">
                      {{ lora.path }}
                    </div>
                    <div class="framesync-stack">
                      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                        <span style="font-size:10px; color:#9bc4e2;">Strength</span>
                        <span style="font-size:11px; color:#cfe5f5; font-weight:600;">{{ lora.strength.toFixed(2) }}</span>
                      </div>
                      <input type="range" min="0" max="2" step="0.05" v-model.number="lora.strength" @click.stop @input="updateLoraStrength(lora)" class="framesync-input">
                    </div>
                    <div class="framesync-footer" style="gap:4px; margin-top:8px;">
                      <button class="framesync-button" :class="{active: lora.group==='A'}" @click.stop="assignLoraToGroup(lora, 'A')" style="padding:4px 8px; font-size:10px;">
                        A Group
                      </button>
                      <button class="framesync-button" :class="{active: lora.group==='B'}" @click.stop="assignLoraToGroup(lora, 'B')" style="padding:4px 8px; font-size:10px;">
                        B Group
                      </button>
                      <button class="framesync-button" @click.stop="removeLoraSelection(lora)" style="padding:4px 8px; font-size:10px;">
                        ‚úï
                      </button>
                    </div>
                  </div>
                </div>
              </div>
              <div v-if="loras.available.length === 0" style="margin-top:20px; text-align:center; color:#7fb3d6; font-size:12px;">
                No LoRAs found. Click Refresh to load available LoRAs.
              </div>
            </div>
          </div>
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üéöÔ∏è Active <span class="framesync-accent">LoRAs</span></div>
              </div>
              <div style="margin-top:12px;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
                  <div>
                    <div style="font-size:12px; color:#5af2a9; margin-bottom:8px; font-weight:600;">A GROUP ({{ loras.groupA.length }})</div>
                    <div style="display:grid; gap:6px;">
                      <div v-for="lora in loras.groupA" :key="lora.id" 
                           style="background:#0b1526; border:1px solid #13233d; border-radius:6px; padding:8px; font-size:11px; color:#cfe5f5;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                          <span style="font-weight:600;">{{ lora.name }}</span>
                          <span style="color:#7fb3d6;">{{ lora.strength.toFixed(2) }}</span>
                        </div>
                        <div style="font-size:9px; color:#7fb3d6; margin-top:2px;">
                          Effective: {{ (lora.strength * (1 - prompts.crossfaderValue)).toFixed(2) }}
                        </div>
                      </div>
                      <div v-if="loras.groupA.length === 0" style="font-size:11px; color:#7fb3d6; padding:8px; text-align:center;">
                        No LoRAs in group A
                      </div>
                    </div>
                  </div>
                  <div>
                    <div style="font-size:12px; color:#2de2ff; margin-bottom:8px; font-weight:600;">B GROUP ({{ loras.groupB.length }})</div>
                    <div style="display:grid; gap:6px;">
                      <div v-for="lora in loras.groupB" :key="lora.id" 
                           style="background:#0b1526; border:1px solid #13233d; border-radius:6px; padding:8px; font-size:11px; color:#cfe5f5;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                          <span style="font-weight:600;">{{ lora.name }}</span>
                          <span style="color:#7fb3d6;">{{ lora.strength.toFixed(2) }}</span>
                        </div>
                        <div style="font-size:9px; color:#7fb3d6; margin-top:2px;">
                          Effective: {{ (lora.strength * prompts.crossfaderValue).toFixed(2) }}
                        </div>
                      </div>
                      <div v-if="loras.groupB.length === 0" style="font-size:11px; color:#7fb3d6; padding:8px; text-align:center;">
                        No LoRAs in group B
                      </div>
                    </div>
                  </div>
                </div>
                <div class="framesync-footer" style="margin-top:12px;">
                  <button class="framesync-button" @click="applyLoras">‚úì Apply LoRAs</button>
                  <button class="framesync-button" @click="clearAllLoras">‚úï Clear All</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='MOTION'">
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üéÆ Camera <span class="framesync-accent">Pad</span></div>
              </div>
              <div style="margin-top:12px; display:flex; justify-content:center;">
                <div class="xy-pad" 
                  @mousedown="xyPadMouseDown" 
                  @mousemove="xyPadMouseMove" 
                  @mouseup="xyPadMouseUp" 
                  @mouseleave="xyPadMouseUp"
                  @touchstart="xyPadMouseDown"
                  @touchmove="xyPadMouseMove"
                  @touchend="xyPadMouseUp">
                  <div class="xy-dot framesync" :style="{left: xyPad.x + 'px', top: xyPad.y + 'px', transform: 'translate(-6px, -6px)'}"></div>
                </div>
              </div>
              <div class="framesync-subtitle" style="margin-top:8px; text-align:center;">
                Click/drag to control camera pan (X/Y translation)
              </div>
            </div>
          </div>
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üîç Zoom & <span class="framesync-accent">Tilt</span></div>
              </div>
              <div class="framesync-stack" style="margin-top:12px;">
                <div class="framesync-subtitle">Zoom</div>
                <input type="range" min="-5" max="5" step="0.05" value="0.8" @input="sendControl('liveParam',{translation_z: parseFloat($event.target.value)})" class="framesync-input">
              </div>
              <div class="framesync-stack" style="margin-top:10px;">
                <div class="framesync-subtitle">Tilt</div>
                <input type="range" min="-180" max="180" step="0.5" value="0" @input="sendControl('liveParam',{rotation_z: parseFloat($event.target.value)})" class="framesync-input">
              </div>
            </div>
          </div>
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üé¨ Motion <span class="framesync-accent">Style</span></div>
              </div>
              <div class="framesync-footer" style="margin-top:12px;">
                <button class="framesync-button" v-for="m in motionStyles" :key="m" @click="sendControl('motionStyle',{style:m})">{{ m }}</button>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='MODULATION'">
          <!-- Unified Modulation Tab with FrameSync styling -->
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üéµ Audio & <span class="framesync-accent">Modulation</span></div>
                <div class="pill" :class="{'danger': !audio.uploadedFile}">
                  <span class="dot"></span>
                  {{ audio.uploadedFile ? 'Audio loaded' : 'No audio' }}
                </div>
              </div>
              
              <!-- Audio Upload & BPM Section -->
              <div class="framesync-row" style="grid-template-columns: 1.2fr 1fr 1fr 1fr; margin-top:12px;">
                <div class="framesync-stack">
                  <div class="framesync-panel">
                    <div class="framesync-subtitle">üìÅ Audio Source</div>
                    <div v-if="audio.uploadedFile" class="framesync-list" style="margin:6px 0;">
                      <div class="item">{{ audio.uploadedFile }}</div>
                    </div>
                    <input type="file" accept="audio/*" @change="handleAudioUpload" class="framesync-input" style="font-size:11px;" ref="audioFileInput">
                    <div class="framesync-footer" style="margin-top:6px;">
                      <button class="framesync-button" v-if="audio.uploadedFile" @click="clearAudioFile">‚úï Clear</button>
                    </div>
                  </div>
                </div>
                <div class="framesync-stack">
                  <div class="framesync-panel">
                    <div class="framesync-subtitle">üéµ Tempo (BPM)</div>
                    <input type="number" class="framesync-input" v-model.number="audio.bpm" min="20" max="300" style="font-size:24px; text-align:center; margin:8px 0;">
                    <div class="framesync-footer">
                      <button class="framesync-button">üéØ Detect</button>
                      <button class="framesync-button">üëÜ Tap</button>
                    </div>
                  </div>
                </div>
                <div class="framesync-stack">
                  <div class="framesync-panel">
                    <div class="framesync-subtitle">‚è±Ô∏è Beat Phase</div>
                    <div style="margin:12px 0; text-align:center;">
                      <div class="pill" :class="{'danger': beatPhase < 0.1}" style="font-size:18px;">
                        <span class="dot"></span>
                        {{ Math.round(beatPhase * 100) }}%
                      </div>
                    </div>
                    <div class="framesync-subtitle" style="font-size:10px; text-align:center; color:#7fb3d6;">Beat detection active</div>
                  </div>
                </div>
                <div class="framesync-stack">
                  <div class="framesync-panel">
                    <div class="framesync-subtitle">üéõÔ∏è Global LFO BPM</div>
                    <input type="number" class="framesync-input" v-model.number="lfoBpm" min="20" max="240" style="font-size:18px; text-align:center; margin:8px 0;">
                    <div class="framesync-toggle" @click="() => {}">
                      <span class="framesync-dot"></span> Sync to audio
                    </div>
                  </div>
                </div>
              </div>

              <!-- LFO Modulators Section -->
              <div class="framesync-subtitle" style="margin-top:16px;">üåä LFO Modulators</div>
              <div class="framesync-row" style="grid-template-columns: repeat(3, 1fr); gap:8px; margin-top:8px;">
                <div class="framesync-panel" v-for="(l, idx) in lfos.slice(0, 6)" :key="l.id">
                  <div style="display:flex; gap:6px; align-items:center; justify-content:space-between;">
                    <span style="font-size:11px; color:#9bc4e2;">LFO {{ idx+1 }}</span>
                    <label class="switch" style="cursor:pointer;">
                      <input type="checkbox" v-model="l.on" style="display:none;">
                      <span class="dot" :style="{background: l.on ? '#ff8a1a' : '#444', width:'14px', height:'14px'}"></span>
                    </label>
                  </div>
                  
                  <!-- LFO Preview Graph -->
                  <div class="mod-preview" style="background:#031b2d; border:1px solid #0c3048; border-radius:6px; margin:6px 0; padding:4px;">
                    <svg viewBox="0 0 120 28" preserveAspectRatio="none">
                      <path v-if="l.shape==='Sine'" d="M0 14 C 15 0, 30 28, 45 14 S 75 0, 90 14 S 105 28, 120 14" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                      <path v-else-if="l.shape==='Triangle'" d="M0 22 L30 4 L60 22 L90 4 L120 22" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                      <path v-else-if="l.shape==='Saw'" d="M0 22 L40 4 M40 4 L40 22 L80 4 M80 4 L80 22 L120 4" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                      <path v-else-if="l.shape==='Square'" d="M0 22 L0 4 L40 4 L40 22 L80 22 L80 4 L120 4" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                      <path v-else d="M0 20 L15 14 L30 22 L45 8 L60 20 L75 12 L90 22 L105 10 L120 20" fill="none" stroke="#ff8a1a" stroke-width="2"/>
                    </svg>
                  </div>
                  
                  <div class="fs-field" style="margin-bottom:4px;">
                    <span style="font-size:10px;">Target</span>
                    <select class="framesync-select" v-model="l.target" @change="initLfoBase(l)" style="font-size:11px; padding:4px;">
                      <option value="">None</option>
                      <optgroup v-for="group in lfoTargetGroups" :key="'lfo'+group.label" :label="group.label">
                        <option v-for="t in group.items" :key="'lfo'+t.key" :value="t.key">{{ t.label }}</option>
                      </optgroup>
                    </select>
                  </div>
                  
                  <div class="framesync-buttons" style="gap:4px;">
                    <button class="framesync-button" v-for="s in lfoShapes" :key="s" :class="{active: l.shape===s}" @click="l.shape=s" style="padding:4px 6px; font-size:10px;">
                      {{ s === 'Sine' ? '„Ä∞' : s === 'Triangle' ? '‚ñ≥' : s === 'Saw' ? '‚üã' : '‚ñ≠' }}
                    </button>
                  </div>
                  
                  <div class="fs-field" style="margin-top:4px;">
                    <span style="font-size:10px;">Depth</span>
                    <input type="range" min="0" max="1" step="0.01" v-model.number="l.depth" class="framesync-input" style="padding:2px;">
                  </div>
                  
                  <div class="framesync-footer" style="margin-top:4px;">
                    <button class="framesync-button" @click="removeLfo(idx)" style="font-size:10px;">üóë Del</button>
                  </div>
                </div>
              </div>
              
              <div class="framesync-footer" style="margin-top:8px;">
                <button class="framesync-button" @click="addLfo" v-if="lfos.length<8">‚ûï Add LFO</button>
              </div>

              <!-- Beat Macros Section -->
              <div class="framesync-subtitle" style="margin-top:16px;">‚ö° Beat Macros</div>
              <div class="framesync-row" style="grid-template-columns: repeat(3, 1fr); gap:8px; margin-top:8px;">
                <div class="framesync-panel" v-for="(m, idx) in macrosRack.slice(0, 6)" :key="'mac'+idx">
                  <div style="display:flex; gap:6px; align-items:center; justify-content:space-between;">
                    <span style="font-size:11px; color:#9bc4e2;">Macro {{ idx+1 }}</span>
                    <label class="switch" style="cursor:pointer;">
                      <input type="checkbox" v-model="m.on" style="display:none;">
                      <span class="dot" :style="{background: m.on ? '#ff8a1a' : '#444', width:'14px', height:'14px'}"></span>
                    </label>
                  </div>
                  
                  <div class="fs-field" style="margin-top:6px;">
                    <span style="font-size:10px;">Target</span>
                    <select class="framesync-select" v-model="m.target" style="font-size:11px; padding:4px;">
                      <option>Vibe (CFG)</option>
                      <option>Zoom</option>
                      <option>Noise</option>
                    </select>
                  </div>
                  
                  <div class="framesync-buttons" style="gap:4px; margin-top:4px;">
                    <button class="framesync-button" v-for="s in ['Sine', 'Saw', 'Noise']" :key="s" :class="{active: m.shape===s}" @click="m.shape=s" style="padding:4px 6px; font-size:10px;">
                      {{ s === 'Sine' ? '„Ä∞' : s === 'Saw' ? '‚üã' : '‚óà' }}
                    </button>
                  </div>
                  
                  <div class="fs-field" style="margin-top:4px;">
                    <span style="font-size:10px;">Depth</span>
                    <input type="number" class="framesync-input" v-model.number="m.depth" min="0" max="1" step="0.01" style="padding:4px; font-size:11px;">
                  </div>
                  
                  <div class="framesync-footer" style="margin-top:4px;">
                    <button class="framesync-button" @click="removeMacro(idx)" style="font-size:10px;">üóë Del</button>
                  </div>
                </div>
              </div>
              
              <div class="framesync-footer" style="margin-top:8px;">
                <button class="framesync-button" @click="addMacro" v-if="macrosRack.length<6">‚ûï Add Macro</button>
              </div>

              <!-- Audio Mapping Section (only visible if audio is loaded) -->
              <div v-if="audio.uploadedFile" style="margin-top:16px;">
                <div class="framesync-subtitle">üéöÔ∏è Audio ‚Üí Parameter Mapping</div>
                <div class="framesync-row" style="grid-template-columns: repeat(2, 1fr); gap:8px; margin-top:8px;">
                  <div class="framesync-panel" v-for="(m, idx) in audioMappings.slice(0, 6)" :key="'amap'+idx">
                    <div style="display:flex; gap:6px; align-items:center; justify-content:space-between; margin-bottom:6px;">
                      <span style="font-size:11px; color:#9bc4e2;">Map {{ idx+1 }}</span>
                      <button class="framesync-button" @click="removeAudioMapping(idx)" style="font-size:10px; padding:2px 6px;">‚úï</button>
                    </div>
                    
                    <div class="fs-field" style="margin-bottom:4px;">
                      <span style="font-size:10px;">Target</span>
                      <select class="framesync-select" v-model="m.param" style="font-size:11px; padding:4px;">
                        <option value="">None</option>
                        <optgroup v-for="group in lfoTargetGroups" :key="'amap'+group.label" :label="group.label">
                          <option v-for="t in group.items" :key="'amap'+t.key" :value="t.key">{{ t.label }}</option>
                        </optgroup>
                      </select>
                    </div>
                    
                    <div class="fs-field">
                      <span style="font-size:10px;">Freq Range</span>
                      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:4px;">
                        <input class="framesync-input" type="number" v-model.number="m.freq_min" step="10" style="padding:4px; font-size:10px;" placeholder="Min">
                        <input class="framesync-input" type="number" v-model.number="m.freq_max" step="10" style="padding:4px; font-size:10px;" placeholder="Max">
                      </div>
                    </div>
                    
                    <div class="fs-field" style="margin-top:4px;">
                      <span style="font-size:10px;">Output Range</span>
                      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:4px;">
                        <input class="framesync-input" type="number" v-model.number="m.out_min" step="0.1" style="padding:4px; font-size:10px;" placeholder="Min">
                        <input class="framesync-input" type="number" v-model.number="m.out_max" step="0.1" style="padding:4px; font-size:10px;" placeholder="Max">
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="framesync-footer" style="margin-top:8px;">
                  <button class="framesync-button" @click="addAudioMapping" v-if="audioMappings.length<8">‚ûï Add Mapping</button>
                  <button class="framesync-button" @click="runAudioMod">‚ñ∂ Apply Audio Mapping</button>
                </div>
                <div class="framesync-subtitle" style="margin-top:6px; font-size:10px; text-align:center;">Status: {{ audioStatus }}</div>
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='CONTROLNET'">
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üéØ ControlNet <span class="framesync-accent">Slots</span></div>
              </div>
              <div class="framesync-footer" style="margin-top:12px;">
                <button class="framesync-button" v-for="slot in cn.slots" :key="slot.id" :class="{active: cn.active===slot.id}" @click="cn.active=slot.id">{{ slot.label }}</button>
                <button class="framesync-button" @click="loadControlNetModels">üîÑ Refresh</button>
              </div>
            </div>
          </div>
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">‚öôÔ∏è <span class="framesync-accent">{{ activeSlot.label }}</span> Settings</div>
              </div>
              <div class="framesync-stack" style="margin-top:12px;">
                <div class="framesync-subtitle">Model</div>
                <select class="framesync-select" v-model="activeSlot.model" @change="updateControlNet(activeSlot)">
                  <option v-for="m in cn.availableModels" :key="m.id" :value="m.name">{{ m.name }}</option>
                </select>
              </div>
              <div class="framesync-footer" style="margin-top:10px;">
                <button class="framesync-button" @click="uploadControlNetImage(activeSlot)">üìÅ Change image</button>
                <button class="framesync-button" :class="{active: activeSlot.enabled}" @click="activeSlot.enabled=!activeSlot.enabled; updateControlNet(activeSlot)">{{ activeSlot.enabled ? 'Enabled' : 'Disabled' }}</button>
              </div>
              <div class="framesync-stack" style="margin-top:12px;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                  <div class="framesync-subtitle">Weight</div>
                  <span style="color:#cfe5f5; font-size:12px;">{{ activeSlot.weight.toFixed(2) }}</span>
                </div>
                <input type="range" min="0" max="2" step="0.01" v-model.number="activeSlot.weight" @input="updateControlNet(activeSlot)" class="framesync-input">
              </div>
              <div class="framesync-stack" style="margin-top:10px;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                  <div class="framesync-subtitle">Start</div>
                  <span style="color:#cfe5f5; font-size:12px;">{{ activeSlot.start.toFixed(2) }}</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" v-model.number="activeSlot.start" @input="updateControlNet(activeSlot)" class="framesync-input">
              </div>
              <div class="framesync-stack" style="margin-top:10px;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                  <div class="framesync-subtitle">End</div>
                  <span style="color:#cfe5f5; font-size:12px;">{{ activeSlot.end.toFixed(2) }}</span>
                </div>
                <input type="range" min="0" max="1" step="0.01" v-model.number="activeSlot.end" @input="updateControlNet(activeSlot)" class="framesync-input">
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='SETTINGS'">
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">‚öôÔ∏è <span class="framesync-accent">Engine</span></div>
              </div>
              <div class="framesync-row" style="grid-template-columns: repeat(3, 1fr); gap:10px; margin-top:12px;">
                <div class="framesync-stack">
                  <div class="framesync-subtitle">Resolution</div>
                  <select class="framesync-select"><option>1024x576</option><option>1280x720</option></select>
                </div>
                <div class="framesync-stack">
                  <div class="framesync-subtitle">FPS</div>
                  <select class="framesync-select"><option>24</option><option selected>30</option><option>60</option></select>
                </div>
                <div class="framesync-stack">
                  <div class="framesync-subtitle">Steps</div>
                  <select class="framesync-select"><option>24</option><option>30</option><option>40</option></select>
                </div>
              </div>
              <div class="framesync-footer" style="margin-top:12px;">
                <button class="framesync-button">Seed: 42490527</button>
                <button class="framesync-button">Sampler: DPM++ 2M Karras</button>
              </div>
            </div>
          </div>
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üéπ Controllers <span class="framesync-accent">(WebMIDI)</span></div>
              </div>
              <div v-if="!midi.supported" style="color:#9bc4e2; margin-top:12px; font-size:12px;">WebMIDI not supported or not enabled.</div>
              <div v-else>
                <div class="framesync-footer" style="margin-top:12px;">
                  <button class="framesync-button" v-for="d in midi.devices" :key="d.id" :class="{active: midi.selected===d.id}" @click="midi.selected=d.id">{{ d.name }}</button>
                  <button class="framesync-button" @click="scanMidi()">Rescan</button>
                </div>
                <div class="framesync-footer" style="margin-top:8px;">
                  <button class="framesync-button">Learn mode</button>
                  <button class="framesync-button" @click="addMidiMapping">+ Add Mapping</button>
                  <button class="framesync-button">Status: {{ midiStatus }}</button>
                </div>
                <div style="margin-top:12px; background:#031b2d; border:1px solid #0c3048; border-radius:8px; overflow:hidden;">
                  <table class="table">
                    <thead><tr><th>Control</th><th>CC</th><th>Target</th><th>Actions</th></tr></thead>
                    <tbody>
                      <tr v-for="(m, idx) in midi.mappings" :key="'midi'+idx">
                        <td><input class="framesync-input" v-model="m.control" @change="saveMidiMappings" style="width:100px; padding:4px;"></td>
                        <td><input class="framesync-input" type="number" v-model.number="m.cc" @change="saveMidiMappings" style="width:60px; padding:4px;"></td>
                        <td>
                          <select class="framesync-select" v-model="m.key" @change="saveMidiMappings" style="width:120px; padding:4px;">
                            <option value="">None</option>
                            <option v-for="t in lfoTargets" :key="'mopt'+t.key" :value="t.key">{{ t.label }}</option>
                          </select>
                        </td>
                        <td><button class="framesync-button" @click="deleteMidiMapping(idx)" style="padding:4px 8px; cursor:pointer;">Delete</button></td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
          <div class="rack">
            <div class="framesync-panel">
              <div class="framesync-header">
                <div class="framesync-title">üíæ Preset <span class="framesync-accent">Management</span></div>
              </div>
              <div class="framesync-footer" style="margin-top:12px;">
                <button class="framesync-button" v-for="p in availablePresets" :key="p" :class="{active: currentPreset===p}" @click="loadPreset(p)">{{ p }}</button>
                <button class="framesync-button" @click="refreshPresets">üîÑ Refresh</button>
              </div>
              <div class="framesync-stack" style="margin-top:12px;">
                <div class="framesync-subtitle">New preset name</div>
                <input class="framesync-input" v-model="newPresetName" placeholder="my-preset">
              </div>
              <div class="framesync-footer" style="margin-top:10px;">
                <button class="framesync-button" @click="saveCurrentPreset">üíæ Save current as preset</button>
                <button class="framesync-button" v-if="currentPreset" @click="deletePreset(currentPreset)" style="border-color:#ff4d6d; color:#ff4d6d;">üóë Delete {{ currentPreset }}</button>
              </div>
              <div v-if="presetStatus" class="framesync-subtitle" style="margin-top:8px; text-align:center;">{{ presetStatus }}</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Bottom context panel -->
      <div class="context">
        <div v-if="currentTab==='LIVE'">
          <h4>Beat & MIDI status</h4>
          <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="min-width:240px;">
              <strong>Beat macros ({{ macrosRack.length }})</strong>
              <div v-for="m in macrosRack" :key="m.target" style="font-size:12px; color:var(--muted);">
                ‚Ä¢ {{ m.target }} ‚Äì {{ m.shape }} @ {{ m.speed }} ‚Äì Depth {{ (m.depth*100).toFixed(0) }}%
              </div>
            </div>
            <div style="min-width:240px;">
              <strong>MIDI mappings</strong>
              <div style="font-size:12px; color:var(--muted);">
                ‚Ä¢ LaunchControl CC21 ‚Üí Vibe<br/>
                ‚Ä¢ LaunchControl CC22 ‚Üí Strength<br/>
                ‚Ä¢ LaunchControl CC23 ‚Üí Zoom
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='PROMPTS'">
          <h4>Morph slots</h4>
          <table class="table">
            <thead><tr><th>ID</th><th>On</th><th>Name</th><th>A prompt</th><th>B prompt</th><th>Range</th></tr></thead>
            <tbody>
              <tr v-for="slot in morphSlots" :key="slot.id">
                <td>{{ slot.id }}</td>
                <td>{{ slot.on ? '‚óè' : '‚óã' }}</td>
                <td>{{ slot.name }}</td>
                <td>{{ slot.a }}</td>
                <td>{{ slot.b }}</td>
                <td>{{ slot.range }}</td>
              </tr>
            </tbody>
          </table>
          <div class="chips"><span class="chip">+ Add morph</span><span class="chip">Copy from preset</span></div>
        </div>

        <div v-else-if="currentTab==='MOTION'">
          <h4>Camera curves</h4>
          <div class="wave" style="height:100px; background:#11182a; margin-bottom:8px;"></div>
          <div style="font-size:12px; color:var(--muted);">Pan X/Y and Zoom curves over beats. Tools: Apply Sine/Saw, Smooth, Snap to Beats.</div>
        </div>

        <div v-else-if="currentTab==='MODULATION'">
          <h4>Active modulators</h4>
          <div class="chips">
            <span class="chip" v-for="l in lfos.filter(x => x.on)" :key="'ctx-lfo'+l.id">LFO {{ l.id }}: {{ l.target || 'None' }}</span>
            <span class="chip" v-for="m in macrosRack.filter(x => x.on)" :key="'ctx-mac'+m.target">Macro: {{ m.target }}</span>
          </div>
          <div v-if="audio.uploadedFile" style="margin-top:8px;">
            <div class="wave" style="height:80px; background:#11182a; margin-bottom:8px;"></div>
            <div style="font-size:12px; color:var(--muted);">Audio mappings: {{ audioMappings.filter(m => m.param).length }} active</div>
          </div>
        </div>

        <div v-else-if="currentTab==='CONTROLNET'">
          <h4>Drive parameters</h4>
          <div class="chips">
            <span class="chip">Vibe / CFG</span><span class="chip">Camera pan</span><span class="chip">Zoom pulses</span><span class="chip">Noise / Glitch</span>
          </div>
        </div>

        <div v-else-if="currentTab==='SETTINGS'">
          <h4>MIDI mappings</h4>
          <table class="table">
            <thead><tr><th>Source</th><th>Target</th><th>Mode</th><th>Curve</th></tr></thead>
            <tbody>
              <tr v-for="m in midi.mappings" :key="m.control+'ctx'">
                <td>{{ m.control || ('CC '+m.cc) }}</td>
                <td>
                  <select class="select" v-model="m.key" @change="updateMidiMapping(m)">
                    <option value="">(none)</option>
                    <option v-for="t in lfoTargets" :key="'map'+t.key" :value="t.key">{{ t.label }}</option>
                  </select>
                </td>
                <td>Absolute</td>
                <td>Linear</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          session: "clown_set_01",
          tabs: [
            { id: "LIVE", label: "LIVE" },
            { id: "PROMPTS", label: "PROMPTS" },
            { id: "LORA", label: "LORA" },
            { id: "MOTION", label: "MOTION" },
            { id: "MODULATION", label: "MODULATION" },
            { id: "CONTROLNET", label: "CN" },
            { id: "SETTINGS", label: "SETTINGS" },
          ],
          currentTab: "LIVE",
          stats: { fps: 27, lat: 120 },
          hud: { seed: 42490527 },
          timecode: "00:00.00",
          liveVibe: [
            { key: "cfg", label: "Vibe (CFG)", val: 0.63, min: 0, max: 1.5, step: 0.01 },
            { key: "strength", label: "Strength", val: 0.78, min: 0, max: 1.5, step: 0.01 },
            { key: "noise", label: "Noise/Glitch", val: 0.2, min: 0, max: 1, step: 0.01 },
            { key: "cfgscale", label: "CFG scale", val: 5.0, min: 0, max: 15, step: 0.1 },
          ],
          liveCam: [
            { key: "zoom", label: "Zoom", val: 0.8, min: -5, max: 5, step: 0.05, sourceable: true },
            { key: "panx", label: "Pan X", val: 0.1, min: -1, max: 1, step: 0.05, sourceable: false },
            { key: "pany", label: "Pan Y", val: 0.0, min: -1, max: 1, step: 0.05, sourceable: false },
            { key: "tilt", label: "Tilt / Rotate", val: 0.0, min: -180, max: 180, step: 0.5, sourceable: false },
          ],
          paramSources: {
            cfg: "Manual",
            strength: "Manual",
            noise: "Beat",
            cfgscale: "Manual",
            zoom: "Beat",
          },
          prompts: { pos: "", neg: "", morphOn: true, crossfaderValue: 0.5 },
          morphSlots: [
            { id: 1, on: true, name: "clean ‚Üí mad", a: "clean evil", b: "mad clown", range: "0.40‚Äì1.00" },
            { id: 2, on: true, name: "box ‚Üí tunnel", a: "small box", b: "neon tunnel", range: "0.00‚Äì0.60" },
            { id: 3, on: false, name: "style fade", a: "photographic", b: "anime render", range: "0.20‚Äì0.80" },
          ],
          loras: {
            available: [],
            groupA: [],
            groupB: [],
          },
          motionPresets: {
            Static: { translation_z: 0, translation_x: 0, translation_y: 0, rotation_z: 0, rotation_y: 0 },
            Orbit: { translation_z: 2, rotation_y: 15, translation_x: 0, translation_y: 0, rotation_z: 0 },
            Tunnel: { translation_z: 5, translation_x: 0, translation_y: 0, rotation_z: 0, rotation_y: 0 },
            Handheld: { translation_z: 0.5, translation_x: 0.2, translation_y: 0.1, rotation_z: 2, rotation_y: 0 },
            Chaos: { translation_z: 1.5, translation_x: 0.5, translation_y: 0.3, rotation_z: 5, rotation_y: 10 }
          },
          motionStyles: ["Calm", "Travel", "Spin", "Handheld", "Chaos"],
          xyPad: { x: 0, y: 0, dragging: false, padSize: 140 },
          audio: { track: "", bpm: 114.8, uploadedFile: null },
          audioStatus: "Idle",
          audioMappings: [
            { param: "strength", freq_min: 20, freq_max: 300, out_min: 0, out_max: 1.5 },
            { param: "cfg", freq_min: 300, freq_max: 1200, out_min: 0, out_max: 30 },
            { param: "translation_z", freq_min: 1200, freq_max: 3000, out_min: -5, out_max: 5 },
          ],
          lfoBpm: 120,
          lfoTargets: [
            { key: "cfg", label: "Vibe (CFG)", min: 0, max: 30, default: 6, group: "Style" },
            { key: "strength", label: "Strength", min: 0, max: 1.5, default: 0.7, group: "Style" },
            { key: "noise_multiplier", label: "Noise/Glitch", min: 0, max: 3, default: 1.0, group: "Style" },
            { key: "translation_z", label: "Zoom", min: -10, max: 10, default: 0, group: "Camera" },
            { key: "translation_x", label: "Pan X", min: -10, max: 10, default: 0, group: "Camera" },
            { key: "translation_y", label: "Pan Y", min: -10, max: 10, default: 0, group: "Camera" },
            { key: "rotation_y", label: "Rotate Y", min: -180, max: 180, default: 0, group: "Camera" },
            { key: "rotation_z", label: "Tilt", min: -180, max: 180, default: 0, group: "Camera" },
            { key: "fov", label: "FOV", min: 1, max: 180, default: 70, group: "Camera" },
          ],
          lfoShapes: ["Sine", "Triangle", "Saw", "Square"],
          lfos: Array.from({ length: 6 }).map((_, idx) => ({
            id: idx + 1,
            on: idx === 0,
            target: idx === 0 ? "cfg" : "",
            shape: "Sine",
            bpm: 120,
            depth: 0.1,
            base: null,
            phase: 0,
          })),
          macrosRack: [
            { id: "macro-0", on: true, target: "Vibe (CFG)", shape: "Sine", bpm: 120, depth: 0.7, offset: 0.1, show: true },
            { id: "macro-1", on: true, target: "Zoom", shape: "Saw", bpm: 90, depth: 0.6, offset: 0.2, show: false },
            { id: "macro-2", on: false, target: "Noise/Glitch", shape: "Noise", bpm: 140, depth: 0.3, offset: 0.0, show: false },
            ],
          framesync: {
            presets: ["Basic Strength Schedule", "Basic Noise Schedule", "Basic Init"],
            factoryPresets: ["Basic Strength Schedule", "Basic Noise Schedule", "Basic Init"],
            selectedPreset: "Basic Strength Schedule",
            // Use Cosine as the default/primary wave. Cosine is just a 90¬∞ phase-shifted Sine,
            // but starting at the peak works better for the framesync visualization and metrics.
            primaryWave: "Cosine",
            waveShapes: ["Cosine", "Sine", "Saw", "Triangle", "Square", "Noise"],
            amplitude: 1,
            shift: 0,
            bend: 1,
            noise: 0,
            fps: 24,
            frameCount: 120,
            bpm: 120,
            shiftFrames: 0,
            syncRates: ["1", "1/2", "1/4", "1/8", "1/16", "1/32", "2", "4", "8"],
            syncRate: "1/4",
            decimals: 2,
            metrics: [
              { label: "Max", value: "1.00", sub: "32bars" },
              { label: "Min", value: "-1.00", sub: "16bars" },
              { label: "Avg", value: "0.00", sub: "4bars" },
              { label: "Abs Avg", value: "0.63", sub: "1bar" },
              { label: "Duration", value: "5.00s", sub: "1/2" },
            ],
            timingTable: [
              { label: "32bar", time: "58.0s", frames: "1392.0" },
              { label: "16bar", time: "28.0s", frames: "768.0" },
              { label: "8bar", time: "16.0s", frames: "384.0" },
              { label: "4bar", time: "8.0s", frames: "192.0" },
              { label: "2bar", time: "4.0s", frames: "96.0" },
              { label: "1bar", time: "2.0s", frames: "48.0" },
              { label: "1/2", time: "1.0s", frames: "24.0" },
            ],
            featureCoverage: [
              "Wave presets",
              "LFO modulation",
              "Audio-driven sync",
              "Tempo & shift",
              "Metrics + timing table",
              "Preset import/export"
            ],
          },
          cn: {
            slots: [
              { id: "CN1", label: "CN1", model: "Canny", weight: 0.4, start: 0, end: 0.9, enabled: false },
              { id: "CN2", label: "CN2 ‚Ä¢", model: "Depth", weight: 0.4, start: 0, end: 0.9, enabled: true },
              { id: "CN3", label: "CN3", model: "Pose", weight: 0.4, start: 0, end: 0.9, enabled: false },
              { id: "CN4", label: "CN4", model: "Tile", weight: 0.4, start: 0, end: 0.9, enabled: false },
              { id: "CN5", label: "CN5", model: "Control", weight: 0.4, start: 0, end: 0.9, enabled: false },
            ],
            active: "CN2",
            availableModels: [],
          },
          midi: {
            supported: !!navigator.requestMIDIAccess,
            devices: [],
            selected: null,
            mappings: [
              { control: "LaunchControl CC21", cc: 21, key: "cfg" },
              { control: "LaunchControl CC22", cc: 22, key: "strength" },
              { control: "LaunchControl CC23", cc: 23, key: "cfgscale" },
            ],
          },
          midiStatus: "Ready",
          ws: null,
          wsStatus: "disconnected",
          streamSrc: "/hls/live/deforum.m3u8",
          thumbs: [],
          framesTimer: null,
          playerEl: null,
          timeHandler: null,
          hls: null,
          liveParamTimers: {},
          liveParamPending: {},
          lastParamSent: {},
          controlDelayMs: 75,
          errorHandler: null,
          playbackTimer: null,
          lfoTimer: null,
          lastLfoTick: null,
          beatTimer: null,
          lastBeatTime: null,
          beatCount: 0,
          beatPhase: 0,
          lastMacroTrigger: {},
          availablePresets: [],
          currentPreset: null,
          newPresetName: "",
          presetStatus: "",
          isPlaying: false,
          isRecording: false,
          streamUrl: "",
          previewBarCollapsed: false,
        };
      },
      computed: {
        activeSlot() {
          return this.cn.slots.find((s) => s.id === this.cn.active) || this.cn.slots[0];
        },
        lfoTargetGroups() {
          const groups = {};
          this.lfoTargets.forEach((target) => {
            const label = target.group || "Other";
            if (!groups[label]) groups[label] = [];
            groups[label].push(target);
          });
          return Object.entries(groups).map(([label, items]) => ({ label, items }));
        },
      },
      mounted() {
        this.attachPlayer();
        this.setupWS();
        this.scanMidi();
        this.refreshFrames();
        this.refreshPresets();
        this.loadControlNetModels();
        this.refreshLoras();
        if (typeof fetch === "function") {
          this.framesTimer = setInterval(() => this.refreshFrames(), 5000);
        }
        this.playbackTimer = setInterval(() => this.ensureLivePlayback(), 4000);
        this.lfoTimer = setInterval(() => this.runLfos(), 120);
        this.beatTimer = setInterval(() => this.processBeat(), 50);
      },
      beforeUnmount() {
        if (this.framesTimer) clearInterval(this.framesTimer);
        if (this.playbackTimer) clearInterval(this.playbackTimer);
        if (this.lfoTimer) clearInterval(this.lfoTimer);
        if (this.beatTimer) clearInterval(this.beatTimer);
        if (this.playerEl && this.timeHandler) {
          this.playerEl.removeEventListener("timeupdate", this.timeHandler);
        }
        if (this.playerEl && this.errorHandler) {
          this.playerEl.removeEventListener("error", this.errorHandler);
        }
      },
      methods: {
        switchTab(id) {
          this.currentTab = id;
        },
        togglePlayPause() {
          const video = this.playerEl || document.getElementById("player");
          if (!video) return;
          if (video.paused) {
            video.play()
              .then(() => { this.isPlaying = true; })
              .catch(e => {
                console.error("Play failed:", e);
                this.isPlaying = false;
              });
          } else {
            video.pause();
            this.isPlaying = false;
          }
        },
        stopVideo() {
          const video = this.playerEl || document.getElementById("player");
          if (!video) return;
          video.pause();
          video.currentTime = 0;
          this.isPlaying = false;
        },
        async toggleRecord() {
          if (this.isRecording) {
            // Stop recording
            this.isRecording = false;
            this.sendControl('record', { action: 'stop' });
          } else {
            // Start recording
            this.isRecording = true;
            this.sendControl('record', { action: 'start' });
            // Generate unique stream URL with timestamp and random component
            const streamId = 'stream_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            this.streamUrl = window.location.origin + '/stream/' + streamId;
            // In production, you would get this from the server response
            console.log('Recording started. Stream URL:', this.streamUrl);
          }
        },
        attachPlayer() {
          const video = document.getElementById("player");
          if (!video) return;
          if (this.playerEl && this.timeHandler) this.playerEl.removeEventListener("timeupdate", this.timeHandler);
          if (this.playerEl && this.errorHandler) this.playerEl.removeEventListener("error", this.errorHandler);
          this.playerEl = video;
          const hlsSource = this.streamSrc.includes("?") ? this.streamSrc + "&t=" + Date.now() : this.streamSrc + "?t=" + Date.now();
          if (this.hls && this.hls.destroy) {
            this.hls.destroy();
            this.hls = null;
          }
          if (video.canPlayType("application/vnd.apple.mpegurl")) {
            video.src = hlsSource;
            video.load();
            this.autoplayVideo(video);
          } else if (typeof Hls !== "undefined" && Hls.isSupported && Hls.isSupported()) {
            const hlsEvents = (Hls && Hls.Events) || { MANIFEST_PARSED: "manifest_parsed", ERROR: "error" };
            this.hls = new Hls({ liveSyncDurationCount: 3 });
            this.hls.loadSource(hlsSource);
            this.hls.attachMedia(video);
            if (this.hls.on) {
              this.hls.on(hlsEvents.MANIFEST_PARSED, () => this.autoplayVideo(video));
              this.hls.on(hlsEvents.ERROR, () => {
                setTimeout(() => this.attachPlayer(), 800);
              });
            }
          } else {
            video.src = hlsSource;
          }
          this.timeHandler = () => {
            if (!isNaN(video.currentTime)) {
              const t = video.currentTime;
              const m = Math.floor(t / 60);
              const s = (t % 60).toFixed(2).padStart(5, "0");
              this.timecode = `${String(m).padStart(2, "0")}:${s}`;
            }
          };
          this.errorHandler = () => {
            setTimeout(() => this.attachPlayer(), 800);
          };
          video.addEventListener("timeupdate", this.timeHandler);
          video.addEventListener("error", this.errorHandler);
          video.addEventListener("play", () => { this.isPlaying = true; });
          video.addEventListener("pause", () => { this.isPlaying = false; });
          this.autoplayVideo(video);
        },
        autoplayVideo(video) {
          const el = video || this.playerEl;
          if (!el || typeof el.play !== "function") return;
          const p = el.play();
          if (p && typeof p.catch === "function") {
            p.then(() => { this.isPlaying = true; }).catch(() => { this.isPlaying = false; });
          }
        },
        ensureLivePlayback() {
          if (!this.playerEl) return;
          if (this.playerEl.paused || this.playerEl.readyState < 2) {
            this.autoplayVideo(this.playerEl);
          }
        },
        lfoTarget(lfo) {
          if (!lfo || !lfo.target) return null;
          return this.lfoTargets.find((t) => t.key === lfo.target) || null;
        },
        initLfoBase(lfo) {
          const target = this.lfoTarget(lfo);
          if (!target) return;
          if (lfo.base === null || lfo.base === undefined) {
            lfo.base = target.default != null ? target.default : (target.min + target.max) / 2;
          } else {
            lfo.base = this.clampVal(lfo.base, target.min, target.max);
          }
        },
        shapeValue(shape, phase) {
          const p = phase % (Math.PI * 2);
          if (shape === "Square") return Math.sin(p) >= 0 ? 1 : -1;
          if (shape === "Saw") return p / Math.PI - 1; // -1..1
          if (shape === "Triangle") return (2 * Math.asin(Math.sin(p))) / Math.PI;
          return Math.sin(p);
        },
        clampVal(v, min, max) {
          if (v === null || v === undefined || Number.isNaN(v)) return min;
          return Math.min(max, Math.max(min, v));
        },
        getNow() {
          return (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
        },
        runLfos(now = this.getNow()) {
          if (this.audio.track) return; // audio sync takes over
          if (this.lastLfoTick === null) {
            this.lastLfoTick = now;
            return;
          }
          const dtSec = (now - this.lastLfoTick) / 1000;
          this.lastLfoTick = now;
          if (dtSec <= 0) return;

          const payload = {};
          this.lfos.forEach((lfo) => {
            if (!lfo.on || !lfo.target) return;
            const target = this.lfoTarget(lfo);
            if (!target) return;
            const bpm = lfo.bpm || this.lfoBpm || 120;
            const depth = this.clampVal(lfo.depth ?? 0, 0, 1);
            const base = lfo.base == null ? (target.default ?? (target.min + target.max) / 2) : this.clampVal(lfo.base, target.min, target.max);
            lfo.base = base;
            const inc = dtSec * (bpm / 60) * Math.PI * 2;
            const phase = (lfo.phase || 0) + inc;
            lfo.phase = phase % (Math.PI * 2);
            const wave = this.shapeValue(lfo.shape, lfo.phase);
            const amp = depth * (target.max - target.min) / 2;
            const value = this.clampVal(base + wave * amp, target.min, target.max);
            payload[target.key] = value;
          });
          if (Object.keys(payload).length) {
            this.sendControl("liveParam", payload);
          }
        },
        processBeat() {
          const now = this.getNow();
          const bpm = this.audio.bpm || 120;
          const beatIntervalMs = (60 / bpm) * 1000;
          
          if (this.lastBeatTime === null) {
            this.lastBeatTime = now;
            this.beatCount = 0;
            this.beatPhase = 0;
            return;
          }
          
          const timeSinceLastBeat = now - this.lastBeatTime;
          
          // Check if a beat should occur
          if (timeSinceLastBeat >= beatIntervalMs) {
            this.lastBeatTime = now;
            this.beatCount++;
            this.triggerBeatMacros(now);
          }
          
          // Update continuous beat phase for smooth animations
          this.beatPhase = (timeSinceLastBeat / beatIntervalMs) % 1;
        },
        triggerBeatMacros(now = this.getNow()) {
          const payload = {};
          const activeMacros = this.macrosRack.filter(m => m.on);
          
          activeMacros.forEach((macro) => {
            const target = this.lfoTargets.find(t => t.label === macro.target || t.key === macro.target);
            if (!target) return;
            
            // Determine if this macro should trigger on this beat
            const shouldTrigger = this.shouldMacroTrigger(macro, now);
            if (!shouldTrigger) return;
            
            // Calculate value based on macro shape
            const base = target.default ?? (target.min + target.max) / 2;
            const depth = this.clampVal(macro.depth ?? 0.5, 0, 1);
            const offset = this.clampVal(macro.offset ?? 0, -1, 1);
            
            let value;
            if (macro.shape === "Noise") {
              // Random value for noise
              value = base + (Math.random() * 2 - 1) * depth * (target.max - target.min) / 2;
            } else {
              // Use shape value at current phase
              const phase = this.beatPhase * Math.PI * 2;
              const wave = this.shapeValue(macro.shape || "Sine", phase);
              value = base + (wave + offset) * depth * (target.max - target.min) / 2;
            }
            
            payload[target.key] = this.clampVal(value, target.min, target.max);
          });
          
          if (Object.keys(payload).length) {
            this.sendControl("liveParam", payload);
          }
        },
        shouldMacroTrigger(macro, now) {
          const bpm = Number(macro.bpm || 0);
          if (bpm > 0) {
            const interval = (60 / bpm) * 1000;
            const last = this.lastMacroTrigger[macro.id] || 0;
            if (now - last >= interval) {
              this.lastMacroTrigger[macro.id] = now;
              return true;
            }
            return false;
          }
          // Fallback: if no BPM (or BPM is 0/invalid), trigger on every beat
          return true;
        },
        setupWS() {
          const url = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws";
          const connect = () => {
            this.ws = new WebSocket(url);
            this.ws.onopen = () => {
              this.wsStatus = "connected";
              console.log("WS connected");
            };
            this.ws.onclose = () => {
              this.wsStatus = "disconnected";
              setTimeout(connect, 1000);
            };
            this.ws.onmessage = (evt) => {
              try {
                const msg = JSON.parse(evt.data);
                if (msg.type === "event") console.log(msg.msg || "event");
                if (msg.type === "stream" && msg.src) {
                  this.streamSrc = msg.src + "?t=" + Date.now();
                  this.attachPlayer();
                }
                if (msg.type === "frame") {
                  this.refreshFrames();
                }
              } catch (_) {}
            };
          };
          connect();
        },
        sendControl(controlType, payload) {
          if (!this.ws || this.ws.readyState !== 1) return;
          const msg = { type: "control", controlType, payload };
          this.ws.send(JSON.stringify(msg));
        },
        updateParam(p, evt) {
          const val = parseFloat(evt.target.value);
          p.val = val;
          this.queueLiveParam(p.key, val);
        },
        setSource(key, source) {
          this.paramSources[key] = source;
          this.sendControl("paramSource", { key, source });
        },
        sourceTip(p) {
          const src = this.paramSources[p.key];
          if (src === "Beat") return "Beat/LFO";
          if (src === "MIDI") return "MIDI mapping";
          return "Manual";
        },
        sendPreset(name) {
          const preset = this.motionPresets[name];
          if (!preset) return;
          this.sendControl("liveParam", preset);
          console.log(`Applied motion preset: ${name}`, preset);
        },
        midiTarget(key) {
          return this.lfoTargets.find((t) => t.key === key) || null;
        },
        updateMidiMapping(map) {
          // noop hook for now; v-model already updates
          return map;
        },
        setMorph(on) {
          this.prompts.morphOn = on;
          this.sendControl("prompts", { morphOn: on });
          if (on) {
            this.applyPromptMorphing();
          }
        },
        applyPromptMorphing() {
          if (!this.prompts.morphOn) return;
          const activeSlots = this.morphSlots.filter(s => s.on);
          if (!activeSlots.length) return;
          let morphedPrompt = this.prompts.pos || "";
          activeSlots.forEach(slot => {
            // TODO: Add slider or auto-calculation for blend weight
            // For now using simple concatenation approach
            morphedPrompt += `, ${slot.a} to ${slot.b} blend`;
          });
          this.sendControl("prompt", { positive: morphedPrompt, negative: this.prompts.neg });
        },
        sendPrompts() {
          this.sendControl("prompt", { positive: this.prompts.pos, negative: this.prompts.neg });
          if (this.prompts.morphOn) {
            this.applyPromptMorphing();
          }
        },
        addMacro() {
          if (this.macrosRack.length >= 6) return;
          const id = `macro-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
          this.macrosRack.push({ id, on: true, target: "Vibe (CFG)", shape: "Sine", bpm: 120, depth: 0.5, offset: 0.0, show: false });
        },
        removeMacro(index) {
          if (this.macrosRack.length <= 1) return;
          this.macrosRack.splice(index, 1);
        },
        addAudioMapping() {
          this.audioMappings.push({ param: "", freq_min: 60, freq_max: 500, out_min: 0, out_max: 1 });
        },
        removeAudioMapping(index) {
          this.audioMappings.splice(index, 1);
        },
        addLfo() {
          const nextId = this.lfos.length ? Math.max(...this.lfos.map((l) => l.id)) + 1 : 1;
          this.lfos.push({
            id: nextId,
            on: true,
            target: "",
            shape: "Sine",
            bpm: this.lfoBpm || 120,
            depth: 0.2,
            base: null,
            phase: 0,
          });
        },
        removeLfo(index) {
          if (this.lfos.length <= 1) return;
          this.lfos.splice(index, 1);
        },
        queueLiveParam(key, val) {
          const now = this.getNow();
          const last = this.lastParamSent[key] || 0;
          this.liveParamPending[key] = val;
          if (now - last > this.controlDelayMs) {
            this.lastParamSent[key] = now;
            this.sendControl("liveParam", { [key]: val });
            return;
          }
          clearTimeout(this.liveParamTimers[key]);
          this.liveParamTimers[key] = setTimeout(() => {
            const v = this.liveParamPending[key];
            delete this.liveParamPending[key];
            this.lastParamSent[key] = this.getNow();
            this.sendControl("liveParam", { [key]: v });
          }, this.controlDelayMs);
        },
        async refreshFrames() {
          if (typeof fetch !== "function") return;
          try {
            const res = await fetch("/api/frames?limit=10", { cache: "no-store" });
            if (!res.ok) return;
            const json = await res.json();
            if (Array.isArray(json.items)) {
              this.thumbs = json.items.map((item) => {
                if (typeof item === "string") {
                  return { src: item, name: item.split("/").pop(), frame: this.parseFrameNumber(item) };
                }
                const src = item.src || item.url || item.path || "";
                const name = item.name || src.split("/").pop();
                const frame = item.frame != null ? item.frame : this.parseFrameNumber(name || src);
                return { src, name, frame };
              });
            }
          } catch (e) {
            console.warn("frames fetch failed", e);
          }
        },
        parseFrameNumber(name) {
          if (!name) return null;
          const match = String(name).match(/(\d{3,})/);
          return match ? parseInt(match.pop(), 10) : null;
        },
        async runAudioMod() {
          if (!this.audio.track) {
            this.audioStatus = "Set audio file first";
            return;
          }
          const mappings = this.audioMappings
            .filter((m) => m.param && !Number.isNaN(m.freq_min) && !Number.isNaN(m.freq_max))
            .map((m) => ({
              param: m.param,
              freq_min: m.freq_min,
              freq_max: m.freq_max,
              out_min: m.out_min ?? 0,
              out_max: m.out_max ?? 1,
            }));
          if (!mappings.length) {
            this.audioStatus = "Add at least one mapping";
            return;
          }
          try {
            const res = await fetch("/api/audio-map", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                audioPath: this.audio.track,
                fps: this.stats.fps || 24,
                mappings,
                live: true,
              }),
            });
            const json = await res.json();
            if (!res.ok || json.error) {
              this.audioStatus = json.error || "Audio processing failed";
            } else {
              this.audioStatus = json.ok ? "Audio sent to mediator" : "Audio processing finished with errors";
            }
          } catch (err) {
            this.audioStatus = String(err);
          }
        },
        frameLabel(t) {
          if (!t) return "?";
          if (t.frame != null && !isNaN(t.frame)) return t.frame;
          if (t.name) return t.name.replace(/\.[^.]+$/, "");
          return t.src || "?";
        },
        async scanMidi() {
          if (!navigator.requestMIDIAccess) {
            this.midi.supported = false;
            return;
          }
          try {
            const access = await navigator.requestMIDIAccess({ sysex: false });
            const devices = [];
            access.inputs.forEach((input) => {
              devices.push({ id: input.id, name: input.name });
              input.onmidimessage = (msg) => this.handleMidi(input, msg);
            });
            this.midi.devices = devices;
            if (!this.midi.selected && devices.length) this.midi.selected = devices[0].id;
            this.loadMidiMappings();
          } catch (e) {
            this.midiStatus = "MIDI not available";
          }
        },
        loadMidiMappings() {
          const storage = (typeof window !== 'undefined' && window.localStorage) || 
                         (typeof global !== 'undefined' && global.window && global.window.localStorage);
          if (!storage) return;
          try {
            const stored = storage.getItem("defora_midi_mappings");
            if (stored) {
              const mappings = JSON.parse(stored);
              if (Array.isArray(mappings) && mappings.length > 0) {
                this.midi.mappings = mappings;
                console.log("Loaded MIDI mappings from localStorage", mappings);
              }
            }
          } catch (e) {
            console.error("Failed to load MIDI mappings", e);
          }
        },
        saveMidiMappings() {
          const storage = (typeof window !== 'undefined' && window.localStorage) || 
                         (typeof global !== 'undefined' && global.window && global.window.localStorage);
          if (!storage) return false;
          try {
            storage.setItem("defora_midi_mappings", JSON.stringify(this.midi.mappings));
            console.log("Saved MIDI mappings to localStorage", this.midi.mappings);
            return true;
          } catch (e) {
            console.error("Failed to save MIDI mappings", e);
            return false;
          }
        },
        addMidiMapping() {
          this.midi.mappings.push({ control: "New Mapping", cc: 0, key: "" });
          this.saveMidiMappings();
        },
        deleteMidiMapping(index) {
          this.midi.mappings.splice(index, 1);
          this.saveMidiMappings();
        },
        updateMidiMapping(map) {
          this.saveMidiMappings();
          return map;
        },
        // Preset management methods
        async refreshPresets() {
          try {
            const res = await fetch("/api/presets");
            const data = await res.json();
            this.availablePresets = data.presets || [];
          } catch (err) {
            console.error("Failed to load presets", err);
          }
        },
        async loadPreset(name) {
          try {
            const res = await fetch(`/api/presets/${name}`);
            const data = await res.json();
            if (data.preset) {
              // Apply preset to current state
              if (data.preset.liveVibe) this.liveVibe = data.preset.liveVibe;
              if (data.preset.liveCam) this.liveCam = data.preset.liveCam;
              if (data.preset.audio) Object.assign(this.audio, data.preset.audio);
              if (data.preset.cn) Object.assign(this.cn, data.preset.cn);
              if (data.preset.lfos) this.lfos = data.preset.lfos;
              if (data.preset.macrosRack) this.macrosRack = data.preset.macrosRack;
              if (data.preset.loras) {
                this.loras.groupA = data.preset.loras.groupA || [];
                this.loras.groupB = data.preset.loras.groupB || [];
                // Sync selection state without fetching (data already restored)
                await this.refreshLoras();
              }
              if (data.preset.prompts) {
                Object.assign(this.prompts, data.preset.prompts);
              }
              this.currentPreset = name;
              this.presetStatus = `Loaded preset: ${name}`;
              setTimeout(() => { this.presetStatus = ""; }, 3000);
            }
          } catch (err) {
            console.error("Failed to load preset", err);
            this.presetStatus = `Error loading preset: ${err.message}`;
          }
        },
        async saveCurrentPreset() {
          const name = this.newPresetName || "untitled";
          const preset = {
            liveVibe: this.liveVibe,
            liveCam: this.liveCam,
            audio: { bpm: this.audio.bpm, track: this.audio.track },
            cn: { slots: this.cn.slots, active: this.cn.active },
            loras: {
              groupA: this.loras.groupA,
              groupB: this.loras.groupB,
            },
            prompts: {
              pos: this.prompts.pos,
              neg: this.prompts.neg,
              morphOn: this.prompts.morphOn,
              crossfaderValue: this.prompts.crossfaderValue,
            },
            lfos: this.lfos,
            macrosRack: this.macrosRack,
            paramSources: this.paramSources,
          };
          try {
            const res = await fetch(`/api/presets/${name}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(preset),
            });
            const data = await res.json();
            if (data.ok) {
              this.currentPreset = name;
              this.presetStatus = `Saved preset: ${name}`;
              this.newPresetName = "";
              await this.refreshPresets();
              setTimeout(() => { this.presetStatus = ""; }, 3000);
            }
          } catch (err) {
            console.error("Failed to save preset", err);
            this.presetStatus = `Error saving preset: ${err.message}`;
          }
        },
        async deletePreset(name) {
          if (!confirm(`Delete preset "${name}"?`)) return;
          try {
            await fetch(`/api/presets/${name}`, { method: "DELETE" });
            this.currentPreset = null;
            this.presetStatus = `Deleted preset: ${name}`;
            await this.refreshPresets();
            setTimeout(() => { this.presetStatus = ""; }, 3000);
          } catch (err) {
            console.error("Failed to delete preset", err);
            this.presetStatus = `Error deleting preset: ${err.message}`;
          }
        },
        // Audio file upload methods
        async handleAudioUpload(evt) {
          const file = evt.target.files[0];
          if (!file) return;
          const maxSizeBytes = 50 * 1024 * 1024; // 50MB
          if (file.size > maxSizeBytes) {
            this.audioStatus = "Audio file is too large. Maximum supported size is 50MB.";
            if (evt && evt.target) {
              evt.target.value = "";
            }
            return;
          }
          this.audioStatus = "Uploading audio‚Ä¶";
          try {
            const data = await new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = () => reject(reader.error || new Error("Failed to read audio file. Ensure the file is under 50MB and try again."));
              reader.readAsDataURL(file);
            });
            const res = await fetch("/api/audio-upload", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name: file.name, data }),
            });
            const json = await res.json();
            if (!res.ok || json.error) {
              throw new Error(json.error || "Upload failed");
            }
            this.audio.uploadedFile = file.name;
            this.audio.track = json.path || file.name;
            this.audioStatus = "Audio uploaded";
          } catch (err) {
            this.audioStatus = String(err);
            console.error("Audio upload failed:", err);
          }
        },
        clearAudioFile() {
          this.audio.uploadedFile = null;
          this.audio.track = "";
          this.audioStatus = "Idle";
          if (this.$refs.audioFileInput) {
            this.$refs.audioFileInput.value = "";
          }
        },
        // ControlNet methods
        async loadControlNetModels() {
          try {
            const res = await fetch("/api/controlnet/models");
            const data = await res.json();
            this.cn.availableModels = data.models || [];
          } catch (err) {
            console.error("Failed to load ControlNet models", err);
          }
        },
        updateControlNet(slot) {
          // Send ControlNet parameters to mediator
          const payload = {
            controlnet_slot: slot.id,
            controlnet_model: slot.model,
            controlnet_weight: slot.weight,
            controlnet_start: slot.start,
            controlnet_end: slot.end,
            controlnet_enabled: slot.enabled,
          };
          this.sendControl("controlNet", payload);
          console.log("Updated ControlNet slot:", slot.id, payload);
        },
        uploadControlNetImage(slot) {
          // Placeholder for image upload functionality
          // In a real implementation, this would open a file picker and upload the image
          console.log("Upload image for slot:", slot.id);
          alert("Image upload functionality not yet implemented. Use SD-Forge UI for now.");
        },
        handleMidi(input, msg) {
          const [status, cc, value] = msg.data;
          const isCC = (status & 0xf0) === 0xb0;
          if (!isCC) return;
          const mapping = this.midi.mappings.find((m) => m.cc === cc);
          const norm = value / 127;
          if (mapping && mapping.key) {
            const target = this.midiTarget(mapping.key);
            if (target) {
              const scaled = target.min + norm * (target.max - target.min);
              this.sendControl("liveParam", { [target.key]: scaled });
            } else {
              this.sendControl("liveParam", { [mapping.key]: norm });
            }
          }
        },
        xyPadMouseDown(evt) {
          this.xyPad.dragging = true;
          this.updateXyPad(evt);
          evt.preventDefault();
        },
        xyPadMouseMove(evt) {
          if (!this.xyPad.dragging) return;
          this.updateXyPad(evt);
          evt.preventDefault();
        },
        xyPadMouseUp() {
          this.xyPad.dragging = false;
        },
        updateXyPad(evt) {
          const pad = evt.currentTarget;
          const rect = pad.getBoundingClientRect();
          let clientX, clientY;
          if (evt.touches && evt.touches.length > 0) {
            clientX = evt.touches[0].clientX;
            clientY = evt.touches[0].clientY;
          } else {
            clientX = evt.clientX;
            clientY = evt.clientY;
          }
          const x = Math.max(0, Math.min(this.xyPad.padSize, clientX - rect.left));
          const y = Math.max(0, Math.min(this.xyPad.padSize, clientY - rect.top));
          this.xyPad.x = x;
          this.xyPad.y = y;
          // Normalize pad coordinates to -1..1, then scale to translation range -10..10
          const normX = (x / this.xyPad.padSize) * 2 - 1;
          const normY = 1 - (y / this.xyPad.padSize) * 2;
          const TRANSLATION_RANGE = 10; // Max translation distance for camera movement
          const translation_x = normX * TRANSLATION_RANGE;
          const translation_y = normY * TRANSLATION_RANGE;
          this.queueLiveParam("translation_x", translation_x);
          this.queueLiveParam("translation_y", translation_y);
        },
        // LoRA management methods
        async refreshLoras() {
          try {
            const res = await fetch("/api/loras");
            const data = await res.json();
            if (data.loras) {
              this.loras.available = data.loras.map((lora) => ({
                id: lora.id || lora.name,
                name: lora.name,
                path: lora.path || "",
                thumbnail: lora.thumbnail || null,
                strength: lora.strength || 1.0,
                selected: false,
                group: null,
              }));
              // Restore selected loras from groups using Map for O(1) lookup
              const loraMap = new Map(this.loras.available.map(l => [l.id, l]));
              this.loras.groupA.forEach((savedLora) => {
                const found = loraMap.get(savedLora.id);
                if (found) {
                  found.selected = true;
                  found.group = "A";
                  found.strength = savedLora.strength;
                }
              });
              this.loras.groupB.forEach((savedLora) => {
                const found = loraMap.get(savedLora.id);
                if (found) {
                  found.selected = true;
                  found.group = "B";
                  found.strength = savedLora.strength;
                }
              });
            }
          } catch (err) {
            console.error("Failed to load LoRAs", err);
          }
        },
        toggleLoraSelection(lora) {
          if (lora.selected) {
            this.removeLoraSelection(lora);
          } else {
            lora.selected = true;
            lora.group = "A";
            this.assignLoraToGroup(lora, "A");
          }
        },
        assignLoraToGroup(lora, group) {
          if (group !== "A" && group !== "B") return;
          
          // Remove from both groups first
          this.loras.groupA = this.loras.groupA.filter((l) => l.id !== lora.id);
          this.loras.groupB = this.loras.groupB.filter((l) => l.id !== lora.id);
          
          // Add to target group
          lora.group = group;
          lora.selected = true;
          const loraData = {
            id: lora.id,
            name: lora.name,
            path: lora.path,
            strength: lora.strength,
            thumbnail: lora.thumbnail,
          };
          
          if (group === "A") {
            this.loras.groupA.push(loraData);
          } else {
            this.loras.groupB.push(loraData);
          }
        },
        removeLoraSelection(lora) {
          lora.selected = false;
          lora.group = null;
          this.loras.groupA = this.loras.groupA.filter((l) => l.id !== lora.id);
          this.loras.groupB = this.loras.groupB.filter((l) => l.id !== lora.id);
        },
        updateLoraStrength(lora) {
          // Update strength in groups as well
          const groupALora = this.loras.groupA.find((l) => l.id === lora.id);
          if (groupALora) {
            groupALora.strength = lora.strength;
          }
          const groupBLora = this.loras.groupB.find((l) => l.id === lora.id);
          if (groupBLora) {
            groupBLora.strength = lora.strength;
          }
        },
        updateCrossfader() {
          // Send crossfader value and update LoRA strengths
          this.sendControl("crossfader", {
            value: this.prompts.crossfaderValue,
            groupA: this.loras.groupA.map((l) => ({
              ...l,
              effectiveStrength: l.strength * (1 - this.prompts.crossfaderValue),
            })),
            groupB: this.loras.groupB.map((l) => ({
              ...l,
              effectiveStrength: l.strength * this.prompts.crossfaderValue,
            })),
          });
        },
        applyLoras() {
          const payload = {
            groupA: this.loras.groupA.map((l) => ({
              name: l.name,
              path: l.path,
              strength: l.strength * (1 - this.prompts.crossfaderValue),
            })),
            groupB: this.loras.groupB.map((l) => ({
              name: l.name,
              path: l.path,
              strength: l.strength * this.prompts.crossfaderValue,
            })),
            crossfaderValue: this.prompts.crossfaderValue,
          };
          this.sendControl("loras", payload);
          console.log("Applied LoRAs with crossfader", payload);
        },
        clearAllLoras() {
          this.loras.available.forEach((lora) => {
            lora.selected = false;
            lora.group = null;
          });
          this.loras.groupA = [];
          this.loras.groupB = [];
          this.sendControl("loras", { groupA: [], groupB: [], crossfaderValue: this.prompts.crossfaderValue });
        },
      },
    }).mount("#app");
  </script>
</body>
</html>
