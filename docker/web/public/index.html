<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Defora Web</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/vue@3.4.27/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --bg: #06080f;
      --panel: #0f1422;
      --panel-2: #11182d;
      --border: #1f2a44;
      --glow1: #ff53d9;
      --glow2: #2de2ff;
      --text: #e8edf7;
      --muted: #9bb1d0;
      --success: #5af2a9;
      --danger: #ff4d6d;
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", Arial, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(255, 83, 217, 0.12), transparent 25%),
                  radial-gradient(circle at 80% 0%, rgba(45, 226, 255, 0.12), transparent 25%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 12px 16px;
      background: rgba(13, 18, 34, 0.8);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(6px);
      display: grid;
      grid-template-columns: 1.4fr 1fr 1fr;
      gap: 10px;
      align-items: center;
    }
    .brand { font-weight: 700; letter-spacing: 0.5px; font-size: 18px; }
    .tabs { display: flex; gap: 6px; flex-wrap: wrap; }
    .tab { padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border); background: #0f172a; color: var(--muted); cursor: pointer; }
    .tab.active { border-color: var(--glow2); color: var(--text); box-shadow: 0 6px 20px rgba(45,226,255,0.12); }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 999px; border: 1px solid var(--border); background: #11182d; color: var(--muted); font-size: 12px; }
    .pill .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--success); box-shadow: 0 0 8px var(--success); }
    .pill.danger .dot { background: var(--danger); box-shadow: 0 0 8px var(--danger); }
    .btn { background: linear-gradient(90deg, var(--glow1), var(--glow2)); color: #0a0c12; border: none; border-radius: 999px; padding: 8px 12px; font-weight: 700; cursor: pointer; }
    .btn.ghost { background: #0f172a; color: var(--text); border: 1px solid var(--border); }
    .layout { flex: 1; display: grid; grid-template-columns: 1.8fr 1fr; gap: 10px; padding: 10px; }
    .preview { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); padding: 10px; display: grid; gap: 10px; }
    .video-wrap { position: relative; border-radius: var(--radius); overflow: hidden; border: 1px solid var(--border); background: #000; }
    video { width: 100%; display: block; background: #000; }
    .overlay { position: absolute; left: 0; right: 0; bottom: 0; display: flex; justify-content: space-between; padding: 8px 10px; background: linear-gradient(180deg, transparent, rgba(0,0,0,0.7)); font-size: 12px; }
    .timeline { background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 8px; }
    .thumbs { display: flex; gap: 8px; overflow-x: auto; margin-bottom: 6px; padding-bottom: 4px; }
    .thumb-card { position: relative; border-radius: 10px; overflow: hidden; border: 1px solid var(--border); background: #0b0f1c; box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
    .thumb { width: 92px; height: 54px; display: block; background: #11182a; object-fit: cover; }
    .thumb-label { position: absolute; left: 0; right: 0; bottom: 0; padding: 3px 6px; font-size: 11px; color: var(--text); background: linear-gradient(180deg, transparent, rgba(0,0,0,0.7)); }
    .wave { height: 40px; border-radius: 8px; background: linear-gradient(90deg, rgba(255,83,217,0.2), rgba(45,226,255,0.2)); border: 1px solid var(--border); }
    .rack { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .rack h3 { margin: 0 0 8px 0; }
    .slider-row { display: grid; grid-template-columns: 1.1fr 1fr; gap: 8px; align-items: center; margin: 8px 0; font-size: 13px; color: var(--muted); }
    .slider-row input[type=range] { width: 100%; accent-color: var(--glow2); }
    .source { display: inline-flex; gap: 6px; font-size: 12px; color: var(--muted); align-items: center; }
    .chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { padding: 8px 12px; border-radius: 999px; border: 1px solid var(--border); background: #11182a; color: var(--text); cursor: pointer; }
    .chip.active { border-color: var(--glow2); color: var(--glow2); }
    .context { grid-column: 1 / span 2; background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; }
    .context h4 { margin: 0 0 6px 0; }
    .table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text); }
    .table th, .table td { padding: 6px 8px; border-bottom: 1px solid var(--border); text-align: left; }
    .xy-pad { width: 140px; height: 140px; border-radius: 12px; border: 1px solid var(--border); background: #0f172a; position: relative; cursor: crosshair; user-select: none; }
    .xy-dot { position: absolute; width: 12px; height: 12px; border-radius: 50%; background: var(--glow2); box-shadow: 0 0 10px var(--glow2); }
    .lfo-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; }
    .lfo-card { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: #0e1322; box-shadow: 0 8px 18px rgba(0,0,0,0.28); }
    .lfo-card h4 { margin: 0 0 6px 0; display: flex; align-items: center; justify-content: space-between; font-size: 14px; }
    .lfo-card .meta { font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    .lfo-card select, .lfo-card input[type=number] { width: 100%; padding: 6px; border-radius: 8px; border: 1px solid var(--border); background: #0f172a; color: var(--text); }
    .lfo-card .switch { display: inline-flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px; color: var(--muted); }
    .audio-map-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: 10px; }
    .audio-map-card { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #0f172a; }
    @media (max-width: 1100px) {
      .layout { grid-template-columns: 1fr; }
      .context { grid-column: 1; }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="brand">Defora ¬∑ Session: {{ session }}</div>
      <div class="tabs">
        <button class="tab" v-for="tab in tabs" :key="tab.id" :class="{active: currentTab===tab.id}" @click="switchTab(tab.id)">
          {{ tab.label }}
        </button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
        <button class="btn" @click="sendControl('transport',{action:'toggle'})">‚èØ</button>
        <button class="btn ghost" @click="sendControl('transport',{action:'stop'})">‚èπ</button>
        <button class="btn ghost" @click="sendControl('transport',{action:'record'})">‚óè Rec</button>
        <div class="pill"><span>FPS</span><strong>{{ stats.fps }}</strong></div>
        <div class="pill"><span>Lat</span><strong>{{ stats.lat }}ms</strong></div>
      </div>
    </header>

    <div class="layout">
      <!-- Left: video + mini timeline -->
      <div class="preview">
        <div class="video-wrap">
          <video id="player" controls autoplay muted playsinline></video>
          <div class="overlay">
            <div>Time {{ timecode }}</div>
            <div>Seed {{ hud.seed }}</div>
          </div>
        </div>
        <div class="timeline">
          <div class="thumbs">
            <template v-if="thumbs.length">
              <div class="thumb-card" v-for="t in thumbs" :key="t.src">
                <img class="thumb" :src="t.src" loading="lazy" :alt="'frame '+frameLabel(t)" />
                <div class="thumb-label">#{{ frameLabel(t) }}</div>
              </div>
            </template>
            <template v-else>
              <div class="thumb-card" v-for="n in 6" :key="'ph'+n">
                <div class="thumb"></div>
                <div class="thumb-label">waiting‚Ä¶</div>
              </div>
            </template>
          </div>
          <div class="wave"></div>
        </div>
      </div>

      <!-- Right: control rack per tab -->
      <div>
        <div v-if="currentTab==='LIVE'">
          <div class="rack">
            <h3>Vibe & Style</h3>
            <div class="slider-row" v-for="p in liveVibe" :key="p.key">
              <div>{{ p.label }}</div>
              <div>
                <input type="range" :min="p.min" :max="p.max" :step="p.step" :value="p.val" @input="updateParam(p,$event)">
                <div class="source">
                  <span :title="sourceTip(p)">Source: </span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Manual'}" @click="setSource(p.key,'Manual')">Manual</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Beat'}" @click="setSource(p.key,'Beat')">üåä Beat</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='MIDI'}" @click="setSource(p.key,'MIDI')">üéõ MIDI</span>
                </div>
              </div>
            </div>
          </div>
          <div class="rack">
            <h3>Camera</h3>
            <div class="slider-row" v-for="p in liveCam" :key="p.key">
              <div>{{ p.label }}</div>
              <div>
                <input type="range" :min="p.min" :max="p.max" :step="p.step" :value="p.val" @input="updateParam(p,$event)">
                <div class="source" v-if="p.sourceable">
                  <span class="chip" :class="{active: paramSources[p.key]==='Manual'}" @click="setSource(p.key,'Manual')">Manual</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='Beat'}" @click="setSource(p.key,'Beat')">üåä Beat</span>
                  <span class="chip" :class="{active: paramSources[p.key]==='MIDI'}" @click="setSource(p.key,'MIDI')">üéõ MIDI</span>
                </div>
              </div>
            </div>
            <div class="chips">
              <span class="chip" v-for="p in motionPresets" :key="p" @click="sendPreset(p)">{{ p }}</span>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='PROMPTS'">
          <div class="rack">
            <h3>Positive prompt</h3>
            <input class="select" v-model="prompts.pos" @change="sendPrompts" placeholder="positive prompt" />
            <button class="btn ghost" style="margin-top:6px;" @click="sendPrompts">Apply prompt</button>
          </div>
          <div class="rack">
            <h3>Negative prompt</h3>
            <input class="select" v-model="prompts.neg" @change="sendPrompts" placeholder="negative prompt" />
            <button class="btn ghost" style="margin-top:6px;" @click="sendPrompts">Apply negative</button>
          </div>
          <div class="rack">
            <h3>Prompt morphing</h3>
            <div class="chips">
              <span class="chip" :class="{active: prompts.morphOn}" @click="setMorph(true)">‚òë Enable</span>
              <span class="chip" :class="{active: !prompts.morphOn}" @click="setMorph(false)">‚òê Disable</span>
            </div>
            <div class="wave" style="margin-top:6px; height:24px; background: linear-gradient(90deg, var(--glow1), var(--glow2));"></div>
          </div>
        </div>

        <div v-else-if="currentTab==='MOTION'">
          <div class="rack">
            <h3>Camera pad</h3>
            <div class="xy-pad" 
              @mousedown="xyPadMouseDown" 
              @mousemove="xyPadMouseMove" 
              @mouseup="xyPadMouseUp" 
              @mouseleave="xyPadMouseUp"
              @touchstart="xyPadMouseDown"
              @touchmove="xyPadMouseMove"
              @touchend="xyPadMouseUp">
              <div class="xy-dot" :style="{left: xyPad.x + 'px', top: xyPad.y + 'px', transform: 'translate(-6px, -6px)'}"></div>
            </div>
            <div style="font-size: 11px; color: var(--muted); margin-top: 6px;">
              Click/drag to control camera pan (X/Y translation)
            </div>
          </div>
          <div class="rack">
            <h3>Zoom & Tilt</h3>
            <div class="slider-row">
              <div>Zoom</div>
              <input type="range" min="-5" max="5" step="0.05" value="0.8" @input="sendControl('liveParam',{translation_z: parseFloat($event.target.value)})">
            </div>
            <div class="slider-row">
              <div>Tilt</div>
              <input type="range" min="-180" max="180" step="0.5" value="0" @input="sendControl('liveParam',{rotation_z: parseFloat($event.target.value)})">
            </div>
          </div>
          <div class="rack">
            <h3>Motion style</h3>
            <div class="chips">
              <span class="chip" v-for="m in motionStyles" :key="m" @click="sendControl('motionStyle',{style:m})">{{ m }}</span>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='AUDIO'">
          <div class="rack">
            <h3>Track & tempo</h3>
            <div class="slider-row"><div>Track</div><input class="select" v-model="audio.track"></div>
            <div class="slider-row"><div>BPM</div><input class="select" type="number" v-model.number="audio.bpm"></div>
            <div class="chips" style="margin-top:6px;">
              <span class="chip">Re-detect</span>
              <span class="chip">Tap tempo</span>
              <span class="chip">Add tempo change</span>
            </div>
          </div>
          <div class="rack">
            <h3>Audio band mappings</h3>
            <div class="audio-map-grid">
              <div class="audio-map-card" v-for="(m, idx) in audioMappings" :key="'map'+idx">
                <div class="meta">Target</div>
                <select v-model="m.param">
                  <option value="">(none)</option>
                  <option v-for="t in lfoTargets" :key="'amap'+t.key" :value="t.key">{{ t.label }}</option>
                </select>
                <div class="slider-row" style="margin-top:6px;">
                  <div>Freq min</div><input type="number" min="0" step="10" v-model.number="m.freq_min">
                </div>
                <div class="slider-row">
                  <div>Freq max</div><input type="number" min="0" step="10" v-model.number="m.freq_max">
                </div>
                <div class="slider-row">
                  <div>Out min</div><input type="number" step="0.01" v-model.number="m.out_min">
                </div>
                <div class="slider-row">
                  <div>Out max</div><input type="number" step="0.01" v-model.number="m.out_max">
                </div>
              </div>
            </div>
            <div class="chips" style="margin-top:8px;">
              <span class="chip" @click="addAudioMapping" v-if="audioMappings.length<6">+ Add mapping</span>
              <span class="chip" @click="runAudioMod">Process audio ‚Üí mediator</span>
              <span class="chip" style="color:var(--muted);">Status: {{ audioStatus }}</span>
            </div>
          </div>
          <div class="rack">
            <h3>Manual LFOs (no audio sync)</h3>
            <div class="slider-row">
              <div>Global BPM</div>
              <input class="select" type="number" min="20" max="240" step="1" v-model.number="lfoBpm">
            </div>
            <div class="lfo-grid">
              <div class="lfo-card" v-for="l in lfos" :key="l.id">
                <h4>
                  LFO {{ l.id }}
                  <span class="switch" @click="l.on=!l.on">
                    <span class="dot" :style="{background: l.on ? 'var(--success)' : '#444'}"></span>
                    {{ l.on ? 'ON' : 'OFF' }}
                  </span>
                </h4>
                <div class="meta">Target</div>
                <select v-model="l.target" @change="initLfoBase(l)">
                  <option value="">(none)</option>
                  <option v-for="t in lfoTargets" :key="t.key" :value="t.key">{{ t.label }}</option>
                </select>
                <div class="meta" style="margin-top:6px;">Shape</div>
                <select v-model="l.shape">
                  <option v-for="s in lfoShapes" :key="s">{{ s }}</option>
                </select>
                <div class="slider-row" style="margin-top:6px;">
                  <div>BPM</div>
                  <input type="number" min="20" max="240" step="1" v-model.number="l.bpm">
                </div>
                <div class="slider-row">
                  <div>Base</div>
                  <input type="number" :min="lfoTarget(l) ? lfoTarget(l).min : 0" :max="lfoTarget(l) ? lfoTarget(l).max : 1" step="0.01" v-model.number="l.base">
                </div>
                <div class="slider-row">
                  <div>Depth</div>
                  <input type="range" min="0" max="1" step="0.01" v-model.number="l.depth">
                </div>
              </div>
            </div>
            <div class="meta">LFOs emit liveParam values to the mediator when no audio track is selected.</div>
          </div>
          <div class="rack">
            <h3>Beat macros</h3>
            <div v-for="(m, idx) in macrosRack" :key="'mac'+idx" style="border:1px solid var(--border); border-radius:10px; padding:8px; margin-bottom:6px;">
              <div style="display:flex; gap:6px; align-items:center; justify-content:space-between;">
                <span>Macro {{ idx+1 }}</span>
                <span class="chip" @click="m.on=!m.on">{{ m.on ? 'ON' : 'OFF' }}</span>
              </div>
              <div class="slider-row"><div>Target</div><select class="select" v-model="m.target"><option>Vibe (CFG)</option><option>Zoom</option><option>Noise</option></select></div>
              <div class="slider-row"><div>Shape</div><select class="select" v-model="m.shape"><option>Sine</option><option>Saw</option><option>Noise</option></select></div>
              <div class="slider-row"><div>Speed</div><select class="select" v-model="m.speed"><option>1/4 note</option><option>1 bar</option><option>1/8 note</option></select></div>
              <div class="slider-row"><div>Depth</div><input type="range" min="0" max="1" step="0.01" v-model.number="m.depth"></div>
              <div class="slider-row"><div>Offset</div><input type="range" min="-1" max="1" step="0.01" v-model.number="m.offset"></div>
              <div class="chips"><span class="chip" @click="m.show=true">Show in graph</span></div>
            </div>
            <div class="chips"><span class="chip" @click="addMacro" v-if="macrosRack.length<6">+ Add macro</span></div>
          </div>
        </div>

        <div v-else-if="currentTab==='CONTROLNET'">
          <div class="rack">
            <h3>ControlNet slots</h3>
            <div class="chips">
              <span class="chip" v-for="slot in cn.slots" :key="slot.id" :class="{active: cn.active===slot.id}" @click="cn.active=slot.id">{{ slot.label }}</span>
            </div>
          </div>
          <div class="rack">
            <h3>{{ activeSlot.label }}</h3>
            <div class="chips" style="margin-bottom:8px;">
              <span class="chip">Change image</span>
              <span class="chip">Model: {{ activeSlot.model }}</span>
            </div>
            <div class="slider-row"><div>Weight</div><input type="range" min="0" max="1" step="0.01" :value="activeSlot.weight"></div>
            <div class="slider-row"><div>Start</div><input type="range" min="0" max="1" step="0.01" value="0"></div>
            <div class="slider-row"><div>End</div><input type="range" min="0" max="1" step="0.01" value="0.9"></div>
            <div class="chips"><span class="chip">Enabled</span><span class="chip">Bypass</span></div>
          </div>
        </div>

        <div v-else-if="currentTab==='SETTINGS'">
          <div class="rack">
            <h3>Engine</h3>
            <div class="slider-row"><div>Resolution</div><select class="select"><option>1024x576</option><option>1280x720</option></select></div>
            <div class="slider-row"><div>FPS</div><select class="select"><option>24</option><option selected>30</option><option>60</option></select></div>
            <div class="slider-row"><div>Steps</div><select class="select"><option>24</option><option>30</option><option>40</option></select></div>
            <div class="chips">
              <span class="chip">Seed: 42490527</span>
              <span class="chip">Sampler: DPM++ 2M Karras</span>
            </div>
          </div>
          <div class="rack">
            <h3>Controllers (WebMIDI)</h3>
            <div v-if="!midi.supported" style="color:var(--muted);">WebMIDI not supported or not enabled.</div>
            <div v-else>
              <div class="chips" style="margin-bottom:6px;">
                <span class="chip" v-for="d in midi.devices" :key="d.id" :class="{active: midi.selected===d.id}" @click="midi.selected=d.id">{{ d.name }}</span>
                <span class="chip" @click="scanMidi()">Rescan</span>
              </div>
              <div class="chips"><span class="chip">Learn mode</span><span class="chip">Status: {{ midiStatus }}</span></div>
              <table class="table">
                <thead><tr><th>Source</th><th>Target</th><th>Mode</th><th>Curve</th></tr></thead>
                <tbody>
                  <tr v-for="m in midi.mappings" :key="m.control">
                    <td>{{ m.control }}</td><td>{{ m.param }}</td><td>Absolute</td><td>Linear</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Bottom context panel -->
      <div class="context">
        <div v-if="currentTab==='LIVE'">
          <h4>Beat & MIDI status</h4>
          <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="min-width:240px;">
              <strong>Beat macros ({{ macrosRack.length }})</strong>
              <div v-for="m in macrosRack" :key="m.target" style="font-size:12px; color:var(--muted);">
                ‚Ä¢ {{ m.target }} ‚Äì {{ m.shape }} @ {{ m.speed }} ‚Äì Depth {{ (m.depth*100).toFixed(0) }}%
              </div>
            </div>
            <div style="min-width:240px;">
              <strong>MIDI mappings</strong>
              <div style="font-size:12px; color:var(--muted);">
                ‚Ä¢ LaunchControl CC21 ‚Üí Vibe<br/>
                ‚Ä¢ LaunchControl CC22 ‚Üí Strength<br/>
                ‚Ä¢ LaunchControl CC23 ‚Üí Zoom
              </div>
            </div>
          </div>
        </div>

        <div v-else-if="currentTab==='PROMPTS'">
          <h4>Morph slots</h4>
          <table class="table">
            <thead><tr><th>ID</th><th>On</th><th>Name</th><th>A prompt</th><th>B prompt</th><th>Range</th></tr></thead>
            <tbody>
              <tr v-for="slot in morphSlots" :key="slot.id">
                <td>{{ slot.id }}</td>
                <td>{{ slot.on ? '‚óè' : '‚óã' }}</td>
                <td>{{ slot.name }}</td>
                <td>{{ slot.a }}</td>
                <td>{{ slot.b }}</td>
                <td>{{ slot.range }}</td>
              </tr>
            </tbody>
          </table>
          <div class="chips"><span class="chip">+ Add morph</span><span class="chip">Copy from preset</span></div>
        </div>

        <div v-else-if="currentTab==='MOTION'">
          <h4>Camera curves</h4>
          <div class="wave" style="height:100px; background:#11182a; margin-bottom:8px;"></div>
          <div style="font-size:12px; color:var(--muted);">Pan X/Y and Zoom curves over beats. Tools: Apply Sine/Saw, Smooth, Snap to Beats.</div>
        </div>

        <div v-else-if="currentTab==='AUDIO'">
          <h4>Active macro curve</h4>
          <div class="wave" style="height:120px; background:#11182a; margin-bottom:8px;"></div>
          <div class="chips">
            <span class="chip">‚ó† Sine</span><span class="chip">‚ñ≥ Triangle</span><span class="chip">/ Saw</span><span class="chip">‚ß† Square</span><span class="chip">~ Noise</span><span class="chip">‚ô´ From audio peaks</span>
          </div>
        </div>

        <div v-else-if="currentTab==='CONTROLNET'">
          <h4>Drive parameters</h4>
          <div class="chips">
            <span class="chip">Vibe / CFG</span><span class="chip">Camera pan</span><span class="chip">Zoom pulses</span><span class="chip">Noise / Glitch</span>
          </div>
        </div>

        <div v-else-if="currentTab==='SETTINGS'">
          <h4>MIDI mappings</h4>
          <table class="table">
            <thead><tr><th>Source</th><th>Target</th><th>Mode</th><th>Curve</th></tr></thead>
            <tbody>
              <tr v-for="m in midi.mappings" :key="m.control+'ctx'">
                <td>{{ m.control || ('CC '+m.cc) }}</td>
                <td>
                  <select class="select" v-model="m.key" @change="updateMidiMapping(m)">
                    <option value="">(none)</option>
                    <option v-for="t in lfoTargets" :key="'map'+t.key" :value="t.key">{{ t.label }}</option>
                  </select>
                </td>
                <td>Absolute</td>
                <td>Linear</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          session: "clown_set_01",
          tabs: [
            { id: "LIVE", label: "LIVE" },
            { id: "PROMPTS", label: "PROMPTS" },
            { id: "MOTION", label: "MOTION" },
            { id: "AUDIO", label: "AUDIO/BEATS" },
            { id: "CONTROLNET", label: "CN" },
            { id: "SETTINGS", label: "SETTINGS" },
          ],
          currentTab: "LIVE",
          stats: { fps: 27, lat: 120 },
          hud: { seed: 42490527 },
          timecode: "00:00.00",
          liveVibe: [
            { key: "cfg", label: "Vibe (CFG)", val: 0.63, min: 0, max: 1.5, step: 0.01 },
            { key: "strength", label: "Strength", val: 0.78, min: 0, max: 1.5, step: 0.01 },
            { key: "noise", label: "Noise/Glitch", val: 0.2, min: 0, max: 1, step: 0.01 },
            { key: "cfgscale", label: "CFG scale", val: 5.0, min: 0, max: 15, step: 0.1 },
          ],
          liveCam: [
            { key: "zoom", label: "Zoom", val: 0.8, min: -5, max: 5, step: 0.05, sourceable: true },
            { key: "panx", label: "Pan X", val: 0.1, min: -1, max: 1, step: 0.05, sourceable: false },
            { key: "pany", label: "Pan Y", val: 0.0, min: -1, max: 1, step: 0.05, sourceable: false },
            { key: "tilt", label: "Tilt / Rotate", val: 0.0, min: -180, max: 180, step: 0.5, sourceable: false },
          ],
          paramSources: {
            cfg: "Manual",
            strength: "Manual",
            noise: "Beat",
            cfgscale: "Manual",
            zoom: "Beat",
          },
          prompts: { pos: "", neg: "", morphOn: true },
          morphSlots: [
            { id: 1, on: true, name: "clean ‚Üí mad", a: "clean evil", b: "mad clown", range: "0.40‚Äì1.00" },
            { id: 2, on: true, name: "box ‚Üí tunnel", a: "small box", b: "neon tunnel", range: "0.00‚Äì0.60" },
            { id: 3, on: false, name: "style fade", a: "photographic", b: "anime render", range: "0.20‚Äì0.80" },
          ],
          motionPresets: ["Static", "Orbit", "Tunnel", "Handheld", "Chaos"],
          motionStyles: ["Calm", "Travel", "Spin", "Handheld", "Chaos"],
          xyPad: { x: 0, y: 0, dragging: false, padSize: 140 },
          audio: { track: "", bpm: 114.8 },
          audioStatus: "Idle",
          audioMappings: [
            { param: "strength", freq_min: 20, freq_max: 300, out_min: 0, out_max: 1.5 },
            { param: "cfg", freq_min: 300, freq_max: 1200, out_min: 0, out_max: 30 },
            { param: "translation_z", freq_min: 1200, freq_max: 3000, out_min: -5, out_max: 5 },
          ],
          lfoBpm: 120,
          lfoTargets: [
            { key: "cfg", label: "Vibe (CFG)", min: 0, max: 30, default: 6 },
            { key: "strength", label: "Strength", min: 0, max: 1.5, default: 0.7 },
            { key: "noise_multiplier", label: "Noise/Glitch", min: 0, max: 3, default: 1.0 },
            { key: "translation_z", label: "Zoom", min: -10, max: 10, default: 0 },
            { key: "translation_x", label: "Pan X", min: -10, max: 10, default: 0 },
            { key: "translation_y", label: "Pan Y", min: -10, max: 10, default: 0 },
            { key: "rotation_y", label: "Rotate Y", min: -180, max: 180, default: 0 },
            { key: "rotation_z", label: "Tilt", min: -180, max: 180, default: 0 },
            { key: "fov", label: "FOV", min: 1, max: 180, default: 70 },
          ],
          lfoShapes: ["Sine", "Triangle", "Saw", "Square"],
          lfos: Array.from({ length: 6 }).map((_, idx) => ({
            id: idx + 1,
            on: idx === 0,
            target: idx === 0 ? "cfg" : "",
            shape: "Sine",
            bpm: 120,
            depth: 0.1,
            base: null,
            phase: 0,
          })),
          macrosRack: [
            { on: true, target: "Vibe (CFG)", shape: "Sine", speed: "1/4 note", depth: 0.7, offset: 0.1, show: true },
            { on: true, target: "Zoom", shape: "Saw", speed: "1 bar", depth: 0.6, offset: 0.2, show: false },
            { on: false, target: "Noise/Glitch", shape: "Noise", speed: "1/8 note", depth: 0.3, offset: 0.0, show: false },
            ],
          cn: {
            slots: [
              { id: "CN1", label: "CN1", model: "Canny", weight: 0.4 },
              { id: "CN2", label: "CN2 ‚Ä¢", model: "Depth", weight: 0.4 },
              { id: "CN3", label: "CN3", model: "Pose", weight: 0.4 },
              { id: "CN4", label: "CN4", model: "Tile", weight: 0.4 },
              { id: "CN5", label: "CN5", model: "Control", weight: 0.4 },
            ],
            active: "CN2",
          },
          midi: {
            supported: !!navigator.requestMIDIAccess,
            devices: [],
            selected: null,
            mappings: [
              { control: "LaunchControl CC21", cc: 21, key: "cfg" },
              { control: "LaunchControl CC22", cc: 22, key: "strength" },
              { control: "LaunchControl CC23", cc: 23, key: "cfgscale" },
            ],
          },
          midiStatus: "Ready",
          ws: null,
          wsStatus: "disconnected",
          streamSrc: "/hls/live/deforum.m3u8",
          thumbs: [],
          framesTimer: null,
          playerEl: null,
          timeHandler: null,
          hls: null,
          liveParamTimers: {},
          liveParamPending: {},
          lastParamSent: {},
          controlDelayMs: 75,
          errorHandler: null,
          playbackTimer: null,
          lfoTimer: null,
          lastLfoTick: null,
        };
      },
      computed: {
        activeSlot() {
          return this.cn.slots.find((s) => s.id === this.cn.active) || this.cn.slots[0];
        },
      },
      mounted() {
        this.attachPlayer();
        this.setupWS();
        this.scanMidi();
        this.refreshFrames();
        if (typeof fetch === "function") {
          this.framesTimer = setInterval(() => this.refreshFrames(), 5000);
        }
        this.playbackTimer = setInterval(() => this.ensureLivePlayback(), 4000);
        this.lfoTimer = setInterval(() => this.runLfos(), 120);
      },
      beforeUnmount() {
        if (this.framesTimer) clearInterval(this.framesTimer);
        if (this.playbackTimer) clearInterval(this.playbackTimer);
        if (this.lfoTimer) clearInterval(this.lfoTimer);
        if (this.playerEl && this.timeHandler) {
          this.playerEl.removeEventListener("timeupdate", this.timeHandler);
        }
        if (this.playerEl && this.errorHandler) {
          this.playerEl.removeEventListener("error", this.errorHandler);
        }
      },
      methods: {
        switchTab(id) {
          this.currentTab = id;
        },
        attachPlayer() {
          const video = document.getElementById("player");
          if (!video) return;
          if (this.playerEl && this.timeHandler) this.playerEl.removeEventListener("timeupdate", this.timeHandler);
          if (this.playerEl && this.errorHandler) this.playerEl.removeEventListener("error", this.errorHandler);
          this.playerEl = video;
          const hlsSource = this.streamSrc.includes("?") ? this.streamSrc + "&t=" + Date.now() : this.streamSrc + "?t=" + Date.now();
          if (this.hls && this.hls.destroy) {
            this.hls.destroy();
            this.hls = null;
          }
          if (video.canPlayType("application/vnd.apple.mpegurl")) {
            video.src = hlsSource;
            video.load();
            this.autoplayVideo(video);
          } else if (typeof Hls !== "undefined" && Hls.isSupported && Hls.isSupported()) {
            const hlsEvents = (Hls && Hls.Events) || { MANIFEST_PARSED: "manifest_parsed", ERROR: "error" };
            this.hls = new Hls({ liveSyncDurationCount: 3 });
            this.hls.loadSource(hlsSource);
            this.hls.attachMedia(video);
            if (this.hls.on) {
              this.hls.on(hlsEvents.MANIFEST_PARSED, () => this.autoplayVideo(video));
              this.hls.on(hlsEvents.ERROR, () => {
                setTimeout(() => this.attachPlayer(), 800);
              });
            }
          } else {
            video.src = hlsSource;
          }
          this.timeHandler = () => {
            if (!isNaN(video.currentTime)) {
              const t = video.currentTime;
              const m = Math.floor(t / 60);
              const s = (t % 60).toFixed(2).padStart(5, "0");
              this.timecode = `${String(m).padStart(2, "0")}:${s}`;
            }
          };
          this.errorHandler = () => {
            setTimeout(() => this.attachPlayer(), 800);
          };
          video.addEventListener("timeupdate", this.timeHandler);
          video.addEventListener("error", this.errorHandler);
          this.autoplayVideo(video);
        },
        autoplayVideo(video) {
          const el = video || this.playerEl;
          if (!el || typeof el.play !== "function") return;
          const p = el.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
        },
        ensureLivePlayback() {
          if (!this.playerEl) return;
          if (this.playerEl.paused || this.playerEl.readyState < 2) {
            this.autoplayVideo(this.playerEl);
          }
        },
        lfoTarget(lfo) {
          if (!lfo || !lfo.target) return null;
          return this.lfoTargets.find((t) => t.key === lfo.target) || null;
        },
        initLfoBase(lfo) {
          const target = this.lfoTarget(lfo);
          if (!target) return;
          if (lfo.base === null || lfo.base === undefined) {
            lfo.base = target.default != null ? target.default : (target.min + target.max) / 2;
          } else {
            lfo.base = this.clampVal(lfo.base, target.min, target.max);
          }
        },
        shapeValue(shape, phase) {
          const p = phase % (Math.PI * 2);
          if (shape === "Square") return Math.sin(p) >= 0 ? 1 : -1;
          if (shape === "Saw") return p / Math.PI - 1; // -1..1
          if (shape === "Triangle") return (2 * Math.asin(Math.sin(p))) / Math.PI;
          return Math.sin(p);
        },
        clampVal(v, min, max) {
          if (v === null || v === undefined || Number.isNaN(v)) return min;
          return Math.min(max, Math.max(min, v));
        },
        runLfos(now = (typeof performance !== "undefined" && performance.now ? performance.now() : Date.now())) {
          if (this.audio.track) return; // audio sync takes over
          if (this.lastLfoTick === null) {
            this.lastLfoTick = now;
            return;
          }
          const dtSec = (now - this.lastLfoTick) / 1000;
          this.lastLfoTick = now;
          if (dtSec <= 0) return;

          const payload = {};
          this.lfos.forEach((lfo) => {
            if (!lfo.on || !lfo.target) return;
            const target = this.lfoTarget(lfo);
            if (!target) return;
            const bpm = lfo.bpm || this.lfoBpm || 120;
            const depth = this.clampVal(lfo.depth ?? 0, 0, 1);
            const base = lfo.base == null ? (target.default ?? (target.min + target.max) / 2) : this.clampVal(lfo.base, target.min, target.max);
            lfo.base = base;
            const inc = dtSec * (bpm / 60) * Math.PI * 2;
            const phase = (lfo.phase || 0) + inc;
            lfo.phase = phase % (Math.PI * 2);
            const wave = this.shapeValue(lfo.shape, lfo.phase);
            const amp = depth * (target.max - target.min) / 2;
            const value = this.clampVal(base + wave * amp, target.min, target.max);
            payload[target.key] = value;
          });
          if (Object.keys(payload).length) {
            this.sendControl("liveParam", payload);
          }
        },
        setupWS() {
          const url = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws";
          const connect = () => {
            this.ws = new WebSocket(url);
            this.ws.onopen = () => {
              this.wsStatus = "connected";
              console.log("WS connected");
            };
            this.ws.onclose = () => {
              this.wsStatus = "disconnected";
              setTimeout(connect, 1000);
            };
            this.ws.onmessage = (evt) => {
              try {
                const msg = JSON.parse(evt.data);
                if (msg.type === "event") console.log(msg.msg || "event");
                if (msg.type === "stream" && msg.src) {
                  this.streamSrc = msg.src + "?t=" + Date.now();
                  this.attachPlayer();
                }
                if (msg.type === "frame") {
                  this.refreshFrames();
                }
              } catch (_) {}
            };
          };
          connect();
        },
        sendControl(controlType, payload) {
          if (!this.ws || this.ws.readyState !== 1) return;
          const msg = { type: "control", controlType, payload };
          this.ws.send(JSON.stringify(msg));
        },
        updateParam(p, evt) {
          const val = parseFloat(evt.target.value);
          p.val = val;
          this.queueLiveParam(p.key, val);
        },
        setSource(key, source) {
          this.paramSources[key] = source;
          this.sendControl("paramSource", { key, source });
        },
        sourceTip(p) {
          const src = this.paramSources[p.key];
          if (src === "Beat") return "Beat/LFO";
          if (src === "MIDI") return "MIDI mapping";
          return "Manual";
        },
        sendPreset(name) {
          this.sendControl("motionPreset", { name });
        },
        midiTarget(key) {
          return this.lfoTargets.find((t) => t.key === key) || null;
        },
        updateMidiMapping(map) {
          // noop hook for now; v-model already updates
          return map;
        },
        setMorph(on) {
          this.prompts.morphOn = on;
          this.sendControl("prompts", { morphOn: on });
          if (on) {
            this.applyPromptMorphing();
          }
        },
        applyPromptMorphing() {
          if (!this.prompts.morphOn) return;
          const activeSlots = this.morphSlots.filter(s => s.on);
          if (!activeSlots.length) return;
          let morphedPrompt = this.prompts.pos || "";
          activeSlots.forEach(slot => {
            const weight = 0.5;
            morphedPrompt += `, ${slot.a} to ${slot.b} blend`;
          });
          this.sendControl("prompt", { positive: morphedPrompt, negative: this.prompts.neg });
        },
        sendPrompts() {
          this.sendControl("prompt", { positive: this.prompts.pos, negative: this.prompts.neg });
          if (this.prompts.morphOn) {
            this.applyPromptMorphing();
          }
        },
        addMacro() {
          if (this.macrosRack.length >= 6) return;
          this.macrosRack.push({ on: true, target: "Vibe (CFG)", shape: "Sine", speed: "1/4 note", depth: 0.5, offset: 0.0, show: false });
        },
        addAudioMapping() {
          this.audioMappings.push({ param: "", freq_min: 60, freq_max: 500, out_min: 0, out_max: 1 });
        },
        queueLiveParam(key, val) {
          const now = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
          const last = this.lastParamSent[key] || 0;
          this.liveParamPending[key] = val;
          if (now - last > this.controlDelayMs) {
            this.lastParamSent[key] = now;
            this.sendControl("liveParam", { [key]: val });
            return;
          }
          clearTimeout(this.liveParamTimers[key]);
          this.liveParamTimers[key] = setTimeout(() => {
            const v = this.liveParamPending[key];
            delete this.liveParamPending[key];
            this.lastParamSent[key] = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
            this.sendControl("liveParam", { [key]: v });
          }, this.controlDelayMs);
        },
        async refreshFrames() {
          if (typeof fetch !== "function") return;
          try {
            const res = await fetch("/api/frames?limit=10", { cache: "no-store" });
            if (!res.ok) return;
            const json = await res.json();
            if (Array.isArray(json.items)) {
              this.thumbs = json.items.map((item) => {
                if (typeof item === "string") {
                  return { src: item, name: item.split("/").pop(), frame: this.parseFrameNumber(item) };
                }
                const src = item.src || item.url || item.path || "";
                const name = item.name || src.split("/").pop();
                const frame = item.frame != null ? item.frame : this.parseFrameNumber(name || src);
                return { src, name, frame };
              });
            }
          } catch (e) {
            console.warn("frames fetch failed", e);
          }
        },
        parseFrameNumber(name) {
          if (!name) return null;
          const match = String(name).match(/(\d{3,})/);
          return match ? parseInt(match.pop(), 10) : null;
        },
        async runAudioMod() {
          if (!this.audio.track) {
            this.audioStatus = "Set audio file first";
            return;
          }
          const mappings = this.audioMappings
            .filter((m) => m.param && !Number.isNaN(m.freq_min) && !Number.isNaN(m.freq_max))
            .map((m) => ({
              param: m.param,
              freq_min: m.freq_min,
              freq_max: m.freq_max,
              out_min: m.out_min ?? 0,
              out_max: m.out_max ?? 1,
            }));
          if (!mappings.length) {
            this.audioStatus = "Add at least one mapping";
            return;
          }
          try {
            const res = await fetch("/api/audio-map", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                audioPath: this.audio.track,
                fps: this.stats.fps || 24,
                mappings,
                live: true,
              }),
            });
            const json = await res.json();
            if (!res.ok || json.error) {
              this.audioStatus = json.error || "Audio processing failed";
            } else {
              this.audioStatus = json.ok ? "Audio sent to mediator" : "Audio processing finished with errors";
            }
          } catch (err) {
            this.audioStatus = String(err);
          }
        },
        frameLabel(t) {
          if (!t) return "?";
          if (t.frame != null && !isNaN(t.frame)) return t.frame;
          if (t.name) return t.name.replace(/\.[^.]+$/, "");
          return t.src || "?";
        },
        async scanMidi() {
          if (!navigator.requestMIDIAccess) {
            this.midi.supported = false;
            return;
          }
          try {
            const access = await navigator.requestMIDIAccess({ sysex: false });
            const devices = [];
            access.inputs.forEach((input) => {
              devices.push({ id: input.id, name: input.name });
              input.onmidimessage = (msg) => this.handleMidi(input, msg);
            });
            this.midi.devices = devices;
            if (!this.midi.selected && devices.length) this.midi.selected = devices[0].id;
          } catch (e) {
            this.midiStatus = "MIDI not available";
          }
        },
        handleMidi(input, msg) {
          const [status, cc, value] = msg.data;
          const isCC = (status & 0xf0) === 0xb0;
          if (!isCC) return;
          const mapping = this.midi.mappings.find((m) => m.cc === cc);
          const norm = value / 127;
          if (mapping && mapping.key) {
            const target = this.midiTarget(mapping.key);
            if (target) {
              const scaled = target.min + norm * (target.max - target.min);
              this.sendControl("liveParam", { [target.key]: scaled });
            } else {
              this.sendControl("liveParam", { [mapping.key]: norm });
            }
          }
        },
        xyPadMouseDown(evt) {
          this.xyPad.dragging = true;
          this.updateXyPad(evt);
          evt.preventDefault();
        },
        xyPadMouseMove(evt) {
          if (!this.xyPad.dragging) return;
          this.updateXyPad(evt);
          evt.preventDefault();
        },
        xyPadMouseUp() {
          this.xyPad.dragging = false;
        },
        updateXyPad(evt) {
          const pad = evt.currentTarget;
          const rect = pad.getBoundingClientRect();
          const x = Math.max(0, Math.min(this.xyPad.padSize, evt.clientX - rect.left));
          const y = Math.max(0, Math.min(this.xyPad.padSize, evt.clientY - rect.top));
          this.xyPad.x = x;
          this.xyPad.y = y;
          const normX = (x / this.xyPad.padSize) * 2 - 1;
          const normY = 1 - (y / this.xyPad.padSize) * 2;
          const translation_x = normX * 10;
          const translation_y = normY * 10;
          this.queueLiveParam("translation_x", translation_x);
          this.queueLiveParam("translation_y", translation_y);
        },
      },
    }).mount("#app");
  </script>
</body>
</html>
